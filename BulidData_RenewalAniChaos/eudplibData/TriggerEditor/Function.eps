import PluginVariables as msqcvar;
import py_math;
import Variable as v;

const step		= PVariable();			// SkillStep
const count 		= PVariable();			// SkillCount	
const loop 		= PVariable();			// SkillLoop
const delay		= PVariable();			// wait(value)
const wait		= PVariable();			// SkillWait

const INSERT_KEY = PVariable();

const loopB 		= PVariable();			// SkillLoop2
const loopC 	= PVariable();			// SkillLoop3
const delayB	= PVariable();			// wait(value)2
const delayC	= PVariable();			// wait(value)3

const location 	= PVariable();			// 로케이션 번호
const heroID 	= PVariable();			// 영웅 유닛 번호

const UltimateA	= PVariable();			// 궁극기 1번 소모량
const UltimateB	= PVariable();			// 궁극기 2번 소모량
const UltimateC	= PVariable();			// 궁극기 3번 소모량

const UniqueA	= PVariable();			// 유니크 1번 쿨타임

const distance	= PVariable();			// 거리 관련 변수
const SinAngle 	= PVariable();			// Sin 변수
const CosAngle 	= PVariable();			// Cos 변수

const stb		= StringBuffer();

const HoldLocation = [97, 119, 122, 126, 134, 143, 0, 0];

const CosTableArray = EUDArray(py_eval("[int(round(100*math.cos(math.radians(t)))) for t in range(361)]"));
const SinTableArray 	= EUDArray(py_eval("[int(round(100*math.sin(math.radians(t)))) for t in range(361)]"));

const Rusaruka_Voice 	= PVariable();	// 1
const Chtholly_Voice 	= PVariable();	// 2
const Kiana_Voice 		= PVariable();	// 17
const Yuuna_Voice 		= PVariable();	// 22
const Mayuri_Voice 		= PVariable();	// 23
const Nanami_Voice 		= PVariable();	// 24
const Milim_Voice 		= PVariable();	// 25
const Yume_Voice 		= PVariable();	// 26
const Magane_Voice 	= PVariable();	// 27
const Oda_Voice 		= PVariable();	// 28
const Ekidona_Voice 	= PVariable();	// 29
const Niwa_Voice 		= PVariable();	// 30
const Park_Voice 		= PVariable();	// 31

const p_burrowed 		= UnitProperty(burrowed = true);
const p_hallucinated 	= UnitProperty(hallucinated = true);

const ally				= PVariable();

function Table_Sin(cp, degree, distance);
function Table_Cos(cp, degree, distance);

function Voice_Routine(cp, num)
{
	switch(v.Hero_Num[cp])
	{
	case 1:
		Rusaruka_Voice[0] = num;
		Rusaruka_Voice[1] = num;
		Rusaruka_Voice[2] = num;
		Rusaruka_Voice[3] = num;
		Rusaruka_Voice[4] = num;
		Rusaruka_Voice[5] = num;
		break;
	case 2:
		Chtholly_Voice[0] = num;
		Chtholly_Voice[1] = num;
		Chtholly_Voice[2] = num;
		Chtholly_Voice[3] = num;
		Chtholly_Voice[4] = num;
		Chtholly_Voice[5] = num;
		break;
	case 17:
		Kiana_Voice[0] = num;
		Kiana_Voice[1] = num;
		Kiana_Voice[2] = num;
		Kiana_Voice[3] = num;
		Kiana_Voice[4] = num;
		Kiana_Voice[5] = num;
		break;
	case 22:
		Yuuna_Voice[0] = num;
		Yuuna_Voice[1] = num;
		Yuuna_Voice[2] = num;
		Yuuna_Voice[3] = num;
		Yuuna_Voice[4] = num;
		Yuuna_Voice[5] = num;
		break;
	case 23:
		Mayuri_Voice[0] = num;
		Mayuri_Voice[1] = num;
		Mayuri_Voice[2] = num;
		Mayuri_Voice[3] = num;
		Mayuri_Voice[4] = num;
		Mayuri_Voice[5] = num;
		break;
	case 24:
		Nanami_Voice[0] = num;
		Nanami_Voice[1] = num;
		Nanami_Voice[2] = num;
		Nanami_Voice[3] = num;
		Nanami_Voice[4] = num;
		Nanami_Voice[5] = num;
		break;	
	case 25:
		Milim_Voice[0] = num;
		Milim_Voice[1] = num;
		Milim_Voice[2] = num;
		Milim_Voice[3] = num;
		Milim_Voice[4] = num;
		Milim_Voice[5] = num;
		break;	
	case 26:
		Yume_Voice[0] = num;
		Yume_Voice[1] = num;
		Yume_Voice[2] = num;
		Yume_Voice[3] = num;
		Yume_Voice[4] = num;
		Yume_Voice[5] = num;
		break;	
	case 27:
		Magane_Voice[0] = num;
		Magane_Voice[1] = num;
		Magane_Voice[2] = num;
		Magane_Voice[3] = num;
		Magane_Voice[4] = num;
		Magane_Voice[5] = num;
		break;	
	case 28:
		Oda_Voice[0] = num;
		Oda_Voice[1] = num;
		Oda_Voice[2] = num;
		Oda_Voice[3] = num;
		Oda_Voice[4] = num;
		Oda_Voice[5] = num;
		break;	
	case 29:
		Ekidona_Voice[0] = num;
		Ekidona_Voice[1] = num;
		Ekidona_Voice[2] = num;
		Ekidona_Voice[3] = num;
		Ekidona_Voice[4] = num;
		Ekidona_Voice[5] = num;
		break;	
	case 30:
		Niwa_Voice[0] = num;
		Niwa_Voice[1] = num;
		Niwa_Voice[2] = num;
		Niwa_Voice[3] = num;
		Niwa_Voice[4] = num;
		Niwa_Voice[5] = num;
		break;	
	case 31:
		Park_Voice[0] = num;
		Park_Voice[1] = num;
		Park_Voice[2] = num;
		Park_Voice[3] = num;
		Park_Voice[4] = num;
		Park_Voice[5] = num;
		break;	
		
	}
}

function SetHeroID(cp)
{
	switch(v.Hero_Num[cp])
	{
		case 3:
			heroID[cp] = 74;
			break;
		case 4:
			heroID[cp] = 74;
			break;			
		case 5:
			heroID[cp] = 74;
			break;	
		case 6:
			heroID[cp] = 16;
			break;	
		case 7:
			heroID[cp] = 77;
			break;	
		case 8:
			heroID[cp] = 51;
			break;	
		case 9:
			heroID[cp] = 51;
			break;	
		case 10:
			heroID[cp] = 77;
			break;	
		case 11:
			heroID[cp] = 16;
			break;	
		case 12:
			heroID[cp] = 54;
			break;	
		case 13:
			heroID[cp] = 16;
			break;	
		case 14:
			heroID[cp] = 99;
			break;	
		case 15:
			heroID[cp] = 54;
			break;	
		case 16:
			heroID[cp] = 16;
			break;	
		case 17:
			heroID[cp] = 77;
			break;	
		case 18:
			heroID[cp] = 99;
			break;	
		case 19:
			heroID[cp] = 51;
			break;	
		case 20:
			heroID[cp] = 99;
			break;	
		case 21:
			heroID[cp] = 64;
			break;	
	}
}

function ShieldFix(cp : TrgPlayer, amount)
{
	SetDeaths(cp, SetTo, 1, " `ShieldRecharge");
	v.Shield[cp] = amount;
}

function ComputerAlly(cp : TrgPlayer)
{
	ally[cp] = 1;
	SetSwitch("ComputerAlliy", Set);
       SetAllianceStatus(P7, Ally);
    	SetAllianceStatus(P8, Ally);
}

function MoveLoc(Unit : TrgUnit, cp : TrgPlayer, x, y)
{
	MoveLocation(location[cp], Unit, cp, "Anywhere");
	addloc(location[cp], x, y);
}

function SkillUnitWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, property)
{
	switch (property)
	{
		case 0:
			CreateUnitWithProperties(count, Unit, dwrand() % 8 + 33, cp, UnitProperty(burrowed = true));
			break;
		case 1:
			CreateUnitWithProperties(count, Unit, dwrand() % 8 + 33, cp, UnitProperty(hallucinated = true));
			break;
		case 2:
			CreateUnitWithProperties(count, Unit, dwrand() % 8 + 33, cp, UnitProperty(hallucinated = true, burrowed = true));
			break;
			
	}
	
	SetInvincibility(Enable, Unit, cp, "[Skill]Unit_Wait_ALL");
	MoveUnit(count, Unit, cp, "[Skill]Unit_Wait_ALL", location[cp]);
}

function SkillUnit(cp : TrgPlayer, count, Unit : TrgUnit)
{
	CreateUnit(count, Unit, dwrand() % 8 + 33, cp);
	SetInvincibility(Enable, Unit, cp, "[Skill]Unit_Wait_ALL");
	MoveUnit(count, Unit, cp, "[Skill]Unit_Wait_ALL", location[cp]);
}

function BanReturn(cp)
{
	KillUnit("Protoss Observer", cp);
}

function Slow(cp)
{
	MoveLocation(HoldLocation[cp], heroID[cp], cp, "Anywhere");
	CreateUnit(1, "Zerg Devourer", "[Skill]Unit_Wait_8", cp);
	SetInvincibility(Enable, "Zerg Devourer", cp, "[Skill]Unit_Wait_ALL");
	MoveUnit(1, "Zerg Devourer", cp, "[Skill]Unit_Wait_ALL", HoldLocation[cp]);
	RemoveUnitAt(1, "Zerg Devourer", "Anywhere", cp);
}

function HoldPosition(cp)
{
	Slow(cp);
	MoveLocation(HoldLocation[cp], heroID[cp], cp, "Anywhere");
	Order(heroID[cp], cp, "Anywhere", Move, HoldLocation[cp]);
}

function DotShapeWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, x, y, property)
{
	MoveLoc(heroID[cp], cp, x, y);
	SkillUnitWithProperty(cp, count, Unit, property);
}

function DotShape(cp : TrgPlayer, count, Unit : TrgUnit, x, y)
{
	MoveLoc(heroID[cp], cp, x, y);
	SkillUnit(cp, count, Unit);
}

function SkillWait(cp, count)
{
	delay[cp] = count/83 + 1;
}

function SkillWaitB(cp, count)
{
	delayB[cp] = count/83 + 1;
}

function SkillWaitC(cp, count)
{
	delayC[cp] = count/83 + 1;
}

function SkillEnd(cp)
{
	count[cp] = 999;
	
	v.Shield[cp] = 0;
	SetDeaths(cp, SetTo, 0, " `ShieldRecharge");
	
	if (ally[cp] == 1)
	{
	       SetSwitch("ComputerAlliy", Clear);
	       if (cp < 3)
	    	{
			SetAllianceStatus(P8, Enemy);
		}
		else if (cp >= 3)
		{
			SetAllianceStatus(P7, Enemy);
		}
		ally[cp] = 0;
	}
}

function DoubleShapeWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, x, y, property)
{
	MoveLoc(heroID[cp], cp, x, y);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, -x, -y);
	SkillUnitWithProperty(cp, count, Unit, property);
}

function DoubleShape(cp : TrgPlayer, count, Unit : TrgUnit, x, y)
{
	MoveLoc(heroID[cp], cp, x, y);
	SkillUnit(cp, count, Unit);
	MoveLoc(heroID[cp], cp, -x, -y);
	SkillUnit(cp, count, Unit);
}

function SquareShapeWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, x, y, property)
{
	MoveLoc(heroID[cp], cp, x, y);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, -y, x);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, -x, -y);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, y, -x);
	SkillUnitWithProperty(cp, count, Unit, property);
}

function SquareShapeAtWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, x, y, distanceX, distanceY, property)
{
	MoveLoc(heroID[cp], cp, x + distanceX, y + distanceY);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, -y + distanceX, x + distanceY);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, -x + distanceX, -y + distanceY);
	SkillUnitWithProperty(cp, count, Unit, property);
	MoveLoc(heroID[cp], cp, y + distanceX, -x + distanceY);
	SkillUnitWithProperty(cp, count, Unit, property);
}


function SquareShapeAt(cp : TrgPlayer, count, Unit : TrgUnit, x, y, distanceX, distanceY)
{
	MoveLoc(heroID[cp], cp, x + distanceX, y + distanceY);
	SkillUnit(cp, count, Unit);
	MoveLoc(heroID[cp], cp, -y + distanceX, x + distanceY);
	SkillUnit(cp, count, Unit);
	MoveLoc(heroID[cp], cp, -x + distanceX, -y + distanceY);
	SkillUnit(cp, count, Unit);
	MoveLoc(heroID[cp], cp, y + distanceX, -x + distanceY);
	SkillUnit(cp, count, Unit);
}

function NxNSquareShapeWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, n, interval, property)
{
	var i = 0;
	var destX, destY; 
	var distance = interval / 2;
	var size = n * n;

	for (; i < size / 4; i++)
	{
		if (n == 1)
		{
			MoveLoc(heroID[cp] ,cp, 0, 0);
			SkillUnitWithProperty(cp, count, Unit, property);
		}
		else if (n % 2 == 0)
		{
			destX = i % (n / 2) + 1;
			destY = i / (n / 2) + 1;
			if (destX == 1)
			{
				SquareShapeWithProperty(cp, count, Unit, distance, destY * interval - distance, property);
			}
			else if (destY == 1)
			{
				SquareShapeWithProperty(cp, count, Unit, destX * interval - distance, distance, property);
			}
			else
			{
				SquareShapeWithProperty(cp, count, Unit, destX * interval - distance, destY * interval - distance, property);
			}
		}
		else if (n % 2 == 1)
		{
			destX = i % (n / 2);
			destY = i / (n / 2);
	
			if (i == 0)
			{
				MoveLoc(heroID[cp] ,cp, 0, 0);
				SkillUnitWithProperty(cp, count, Unit, property);
			}
			else if (destY == 0)
			{
				SquareShapeWithProperty(cp, count, Unit, destX * interval, 0, property);
			}
			else
			{
				SquareShapeWithProperty(cp, count, Unit, destX * interval + interval, destY * interval, property);
			}
			
			if (i == size / 4 - 1)
			{
				SquareShapeWithProperty(cp, count, Unit, (n / 2) * interval, 0, property);
			}
		}
	}
}

function NxNSquareShapeAt(cp : TrgPlayer, count, Unit : TrgUnit, n, interval, distanceX, distanceY)
{
	var i = 0;
	var destX, destY; 
	var distance = interval / 2;
	var size = n * n;
	
	for (; i < size / 4; i++)
	{
		if (n == 1)
		{
			MoveLoc(heroID[cp] ,cp, distanceX, distanceY);
			SkillUnit(cp, count, Unit);
		}
		else if (n % 2 == 0)
		{
			destX = i % (n / 2) + 1;
			destY = i / (n / 2) + 1;
			
			if (destX == 1)
			{
				SquareShapeAt(cp, count, Unit, distance, destY * interval - distance, distanceX, distanceY);
			}
			else if (destY == 1)
			{
				SquareShapeAt(cp, count, Unit, destX * interval - distance, distance, distanceX, distanceY);
			}
			else
			{
				SquareShapeAt(cp, count, Unit, destX * interval - distance, destY * interval - distance, distanceX, distanceY);
			}
		}
		else if (n % 2 == 1)
		{
			destX = i % (n / 2);
			destY = i / (n / 2);
	
			if (i == 0)
			{
				MoveLoc(heroID[cp] ,cp, distanceX, distanceY);
				SkillUnit(cp, count, Unit);
			}
			else if (destY == 0)
			{
				SquareShapeAt(cp, count, Unit, destX * interval, 0, distanceX, distanceY);
			}
			else
			{
				SquareShapeAt(cp, count, Unit, destX * interval + interval, destY * interval, distanceX, distanceY);
			}
			
			if (i == size / 4 - 1)
			{
				SquareShapeAt(cp, count, Unit, (n / 2) * interval, 0, distanceX, distanceY);
			}
		}
	}
}

function LineShapeAt(cp : TrgPlayer, count, Unit : TrgUnit, degree, n, interval, distanceX, distanceY)
{
	var i = 0;
	var distance = interval / 2;

	Table_Sin(cp, degree, distance);
	Table_Cos(cp, degree, distance);
	
	var gradientX = CosAngle[cp];
	var gradientY = SinAngle[cp] ;
	
	var Angle_X, Angle_Y;
	
	Table_Sin(cp, degree, interval);
	Table_Cos(cp, degree, interval);
	
	for (; i <= n / 2; i++)
	{
		Angle_X = CosAngle[cp] * i;
		Angle_Y = SinAngle[cp] * i;
		
		if (n % 2 == 0 && i != n / 2)
		{
			MoveLoc(heroID[cp], cp, -Angle_X - gradientX + distanceX, Angle_Y + gradientY + distanceY);
			SkillUnit(cp, count, Unit);
			MoveLoc(heroID[cp], cp, Angle_X + gradientX + distanceX, -Angle_Y - gradientY + distanceY);
			SkillUnit(cp, count, Unit);
		}
		else if (n % 2 == 1)
		{
			if (i == 0)
			{
				MoveLoc(heroID[cp], cp, distanceX, distanceY);
				SkillUnit(cp, count, Unit);
			}
			else
			{
				MoveLoc(heroID[cp], cp, -Angle_X + distanceX, Angle_Y + distanceY);
				SkillUnit(cp, count, Unit);
				MoveLoc(heroID[cp], cp, Angle_X + distanceX, -Angle_Y + distanceY);
				SkillUnit(cp, count, Unit);
			}

		}
	}
	
}

function EdgeShapeWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, degree, n, interval, property)
{
   var i = 0;

   Table_Sin(cp, degree, interval * 14 / 10);
   Table_Cos(cp, degree, interval * 14 / 10);

   var x_o = CosAngle[cp];
   var y_o = SinAngle[cp];

   var distance = (interval * 2) / (n - 1);

   Table_Sin(cp, degree + 45, distance);
   Table_Cos(cp, degree + 45, distance);

   var distance_x = CosAngle[cp];
   var distance_y = SinAngle[cp];
   
   if (n == 1)
   {
      DotShapeWithProperty(cp, 1, Unit, 0, 0, property);
   }
   else if (n > 1)
   {
      for (; i < n - 1; i++)
      {
         SquareShapeWithProperty(cp, 1, Unit, x_o - (distance_x * i), y_o - (distance_y * i), property);
      }
   }
}

function EdgeShapeAtWithProperty(cp : TrgPlayer, count, Unit : TrgUnit, degree, n, interval, x, y, property)
{
   var i = 0;

   Table_Sin(cp, degree, interval * 14 / 10);
   Table_Cos(cp, degree, interval * 14 / 10);

   var x_o = CosAngle[cp];
   var y_o = SinAngle[cp];

   var distance = (interval * 2) / (n - 1);

   Table_Sin(cp, degree + 45, distance);
   Table_Cos(cp, degree + 45, distance);

   var distance_x = CosAngle[cp];
   var distance_y = SinAngle[cp];
   
   if (n == 1)
   {
      DotShapeWithProperty(cp, 1, Unit, x, y, property);
   }
   else if (n > 1)
   {
      for (; i < n - 1; i++)
      {
         SquareShapeAtWithProperty(cp, 1, Unit, x_o - (distance_x * i), y_o - (distance_y * i), x, y, property);
      }
   }
}

function EdgeShapeAt(cp : TrgPlayer, count, Unit : TrgUnit, degree, n, interval, x, y)
{
   var i = 0;

   Table_Sin(cp, degree, interval * 14 / 10);
   Table_Cos(cp, degree, interval * 14 / 10);

   var x_o = CosAngle[cp];
   var y_o = SinAngle[cp];

   var distance = (interval * 2) / (n - 1);

   Table_Sin(cp, degree + 45, distance);
   Table_Cos(cp, degree + 45, distance);

   var distance_x = CosAngle[cp];
   var distance_y = SinAngle[cp];
   
   if (n == 1)
   {
      DotShape(cp, 1, Unit, x, y);
   }
   else if (n > 1)
   {
      for (; i < n - 1; i++)
      {
         SquareShapeAt(cp, 1, Unit, x_o - (distance_x * i), y_o - (distance_y * i), x, y);
      }
   }
}
