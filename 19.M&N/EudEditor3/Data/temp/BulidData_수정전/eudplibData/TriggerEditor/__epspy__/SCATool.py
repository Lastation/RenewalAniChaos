## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import SCAFlexible as scf;
import SCAFlexible as scf
# (Line 2) import SCArchive as sca;
import SCArchive as sca
# (Line 4) const CommandLength = 12;
CommandLength = _CGFW(lambda: [12], 1)[0]
# (Line 9) const ackMax = 0x20;
ackMax = _CGFW(lambda: [0x20], 1)[0]
# (Line 10) const MapDim = 0x600;
MapDim = _CGFW(lambda: [0x600], 1)[0]
# (Line 11) var DisConnectCode = 0xFFFF;
DisConnectCode = EUDCreateVariables(1)
_IGVA([DisConnectCode], lambda: [0xFFFF])
# (Line 14) var MSQCSpecial = 0;
MSQCSpecial = EUDCreateVariables(1)
_IGVA([MSQCSpecial], lambda: [0])
# (Line 15) var MSQCCondiction = 0;
MSQCCondiction = EUDCreateVariables(1)
_IGVA([MSQCCondiction], lambda: [0])
# (Line 16) var MSQCValue = 0;
MSQCValue = EUDCreateVariables(1)
_IGVA([MSQCValue], lambda: [0])
# (Line 18) const MSQCSpecialBuffer = PVariable();
MSQCSpecialBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 19) const MSQCBuffer = PVariable();
MSQCBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 21) function Init(){
@EUDTracedFunc
def Init():
    # (Line 22) EUDRegisterObjectToNamespace("MSQCSpecial", MSQCSpecial);
    EUDTraceLog(22)
    EUDRegisterObjectToNamespace("MSQCSpecial", MSQCSpecial)
    # (Line 23) EUDRegisterObjectToNamespace("MSQCSpecialBuffer", MSQCSpecialBuffer);
    EUDTraceLog(23)
    EUDRegisterObjectToNamespace("MSQCSpecialBuffer", MSQCSpecialBuffer)
    # (Line 24) EUDRegisterObjectToNamespace("MSQCCondiction", MSQCCondiction);
    EUDTraceLog(24)
    EUDRegisterObjectToNamespace("MSQCCondiction", MSQCCondiction)
    # (Line 25) EUDRegisterObjectToNamespace("MSQCValue", MSQCValue);
    EUDTraceLog(25)
    EUDRegisterObjectToNamespace("MSQCValue", MSQCValue)
    # (Line 26) EUDRegisterObjectToNamespace("MSQCBuffer", MSQCBuffer);
    EUDTraceLog(26)
    EUDRegisterObjectToNamespace("MSQCBuffer", MSQCBuffer)
    # (Line 27) }
    # (Line 30) var SCAUseUserMessage = 1;

SCAUseUserMessage = EUDCreateVariables(1)
_IGVA([SCAUseUserMessage], lambda: [1])
# (Line 31) const SCALastMessage = PVariable();
SCALastMessage = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 48) var LastTick;
LastTick = EUDVariable()
# (Line 51) const ConnectStatus = PVariable();
ConnectStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 52) const MaxBuffer = PVariable();
MaxBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 53) const BaseAddrEPD = PVariable();
BaseAddrEPD = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 54) const LoadAddrEPD = PVariable();
LoadAddrEPD = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 55) var index;
index = EUDVariable()
# (Line 56) const rn = PVariable();
rn = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 57) const ack = PVariable();
ack = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 58) const SCACommand = PVariable();
SCACommand = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 59) const DataSlot = PVariable();
DataSlot = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 60) function ReceiveValue(value){
@EUDTracedFunc
def ReceiveValue(value):
    # (Line 61) const CP = getcurpl();
    EUDTraceLog(61)
    CP = f_getcurpl()
    # (Line 62) value = value % 0x10000 + (value / 0x10000) * MapDim;
    EUDTraceLog(62)
    value << (value % 0x10000 + (value // 0x10000) * MapDim)
    # (Line 63) ack[CP] = value / 0x10000;
    EUDTraceLog(63)
    _ARRW(ack, CP) << (value // 0x10000)
    # (Line 64) value = value % 0x10000;
    EUDTraceLog(64)
    value << (value % 0x10000)
    # (Line 65) return value;
    EUDTraceLog(65)
    EUDReturn(value)
    # (Line 66) }
    # (Line 68) function SendValue(seq){

@EUDTracedFunc
def SendValue(seq):
    # (Line 69) const CP = getcurpl();
    EUDTraceLog(69)
    CP = f_getcurpl()
    # (Line 70) const rseq = seq - 1;
    EUDTraceLog(70)
    rseq = seq - 1
    # (Line 71) var value = wread_epd(BaseAddrEPD[CP] + rseq / 2, (rseq % 2) * 2);
    EUDTraceLog(71)
    value = EUDVariable()
    value << (f_wread_epd(BaseAddrEPD[CP] + rseq // 2, (rseq % 2) * 2))
    # (Line 73) seq = seq % ackMax + 1;
    EUDTraceLog(73)
    seq << (seq % ackMax + 1)
    # (Line 74) value += seq * 0x10000;
    EUDTraceLog(74)
    value.__iadd__(seq * 0x10000)
    # (Line 76) if (Memory(0x57F1B0,Exactly,CP)){
    _t1 = EUDIf()
    EUDTraceLog(76)
    if _t1(Memory(0x57F1B0, Exactly, CP)):
        # (Line 77) MSQCValue = value % MapDim + (value / MapDim) * 0x10000;
        EUDTraceLog(77)
        MSQCValue << (value % MapDim + (value // MapDim) * 0x10000)
        # (Line 78) }
        # (Line 79) }
    EUDEndIf()
    # (Line 85) const DateLoadStatus = PVariable();

DateLoadStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 86) const GlobalDataLoadStatus = PVariable();
GlobalDataLoadStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 91) function LoadDataRead(dataLen){
@EUDTracedFunc
def LoadDataRead(dataLen):
    # (Line 92) const CP = getcurpl();
    EUDTraceLog(92)
    CP = f_getcurpl()
    # (Line 94) switch(SCACommand[CP]){
    EUDTraceLog(94)
    EUDSwitch(SCACommand[CP])
    # (Line 95) case 1:
    _t1 = EUDSwitchCase()
    # (Line 96) for(var i = 0 ; i < scf.ObjectCount; i++){
    EUDTraceLog(95)
    if _t1(1):
        EUDTraceLog(96)
        i = EUDVariable()
        i << (0)
        _t2 = EUDWhile()
        EUDTraceLog(96)
        if _t2(i >= scf.ObjectCount, neg=True):
            def _t3():
                EUDTraceLog(96)
                i.__iadd__(1)
            # (Line 97) scf.ResetValue(i, 0);
            EUDTraceLog(97)
            scf.ResetValue(i, 0)
            # (Line 98) }
            # (Line 100) for(var i = 0 ; i < dataLen; i++){
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        EUDTraceLog(100)
        i = EUDVariable()
        i << (0)
        _t4 = EUDWhile()
        EUDTraceLog(100)
        if _t4(i >= dataLen, neg=True):
            def _t5():
                EUDTraceLog(100)
                i.__iadd__(1)
            # (Line 101) i = scf.LoadDataReadValue(LoadAddrEPD[CP], i);
            EUDTraceLog(101)
            i << (scf.LoadDataReadValue(LoadAddrEPD[CP], i))
            # (Line 129) }
            # (Line 130) break;
            EUDSetContinuePoint()
            _t5()
        EUDEndWhile()
        EUDTraceLog(130)
        EUDBreak()
        # (Line 131) case 2:
    _t6 = EUDSwitchCase()
    # (Line 133) const BaseAddres = LoadAddrEPD[CP];
    EUDTraceLog(131)
    if _t6(2):
        EUDTraceLog(133)
        BaseAddres = LoadAddrEPD[CP]
        # (Line 135) const aYM = dwread_epd(BaseAddres);
        EUDTraceLog(135)
        aYM = f_dwread_epd(BaseAddres)
        # (Line 136) sca.Year = aYM / 0x10;
        EUDTraceLog(136)
        _ATTW(sca, 'Year') << (aYM // 0x10)
        # (Line 137) sca.Month = aYM % 0x10;
        EUDTraceLog(137)
        _ATTW(sca, 'Month') << (aYM % 0x10)
        # (Line 139) sca.Day = bread_epd(BaseAddres + 1, 3);
        EUDTraceLog(139)
        _ATTW(sca, 'Day') << (f_bread_epd(BaseAddres + 1, 3))
        # (Line 140) sca.Hour = bread_epd(BaseAddres +1, 2);
        EUDTraceLog(140)
        _ATTW(sca, 'Hour') << (f_bread_epd(BaseAddres + 1, 2))
        # (Line 141) sca.Min = bread_epd(BaseAddres + 1, 1);
        EUDTraceLog(141)
        _ATTW(sca, 'Min') << (f_bread_epd(BaseAddres + 1, 1))
        # (Line 142) sca.Week = bread_epd(BaseAddres + 1 , 0);
        EUDTraceLog(142)
        _ATTW(sca, 'Week') << (f_bread_epd(BaseAddres + 1, 0))
        # (Line 144) DateLoadStatus[CP] = 1;
        EUDTraceLog(144)
        _ARRW(DateLoadStatus, CP) << (1)
        # (Line 145) break;
        EUDTraceLog(145)
        EUDBreak()
        # (Line 146) case 3:
    _t7 = EUDSwitchCase()
    # (Line 148) var value = 0;
    EUDTraceLog(146)
    if _t7(3):
        EUDTraceLog(148)
        value = EUDVariable()
        value << (0)
        # (Line 150) for(var i = 0 ; i < 20; i++){
        EUDTraceLog(150)
        i = EUDVariable()
        i << (0)
        _t8 = EUDWhile()
        EUDTraceLog(150)
        if _t8(i >= 20, neg=True):
            def _t9():
                EUDTraceLog(150)
                i.__iadd__(1)
            # (Line 151) sca.GlobalData[i] = 0;
            EUDTraceLog(151)
            _ARRW(sca.GlobalData, i) << (0)
            # (Line 152) }
            # (Line 154) for(var i = 0 ; i < dataLen; i++){
            EUDSetContinuePoint()
            _t9()
        EUDEndWhile()
        EUDTraceLog(154)
        i = EUDVariable()
        i << (0)
        _t10 = EUDWhile()
        EUDTraceLog(154)
        if _t10(i >= dataLen, neg=True):
            def _t11():
                EUDTraceLog(154)
                i.__iadd__(1)
            # (Line 155) const insepector = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
            EUDTraceLog(155)
            insepector = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
            # (Line 156) if (insepector != 0){
            _t12 = EUDIf()
            EUDTraceLog(156)
            if _t12(insepector == 0, neg=True):
                # (Line 157) const vsize = insepector / 0x100;
                EUDTraceLog(157)
                vsize = insepector // 0x100
                # (Line 158) const index = insepector % 0x100;
                EUDTraceLog(158)
                index_1 = insepector % 0x100
                # (Line 161) if (vsize == 1){
                _t13 = EUDIf()
                EUDTraceLog(161)
                if _t13(vsize == 1):
                    # (Line 162) i++;
                    EUDTraceLog(162)
                    i.__iadd__(1)
                    # (Line 163) const value1 = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    EUDTraceLog(163)
                    value1 = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
                    # (Line 164) i++;
                    EUDTraceLog(164)
                    i.__iadd__(1)
                    # (Line 165) const value2 = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    EUDTraceLog(165)
                    value2 = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
                    # (Line 166) value = value1 * 0x10000 + value2;
                    EUDTraceLog(166)
                    value << (value1 * 0x10000 + value2)
                    # (Line 167) }else if(vsize == 2){
                _t14 = EUDElseIf()
                EUDTraceLog(167)
                if _t14(vsize == 2):
                    # (Line 168) i++;
                    EUDTraceLog(168)
                    i.__iadd__(1)
                    # (Line 169) value = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    EUDTraceLog(169)
                    value << (f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2))
                    # (Line 170) }
                    # (Line 172) sca.GlobalData[index] = value;
                EUDEndIf()
                EUDTraceLog(172)
                _ARRW(sca.GlobalData, index_1) << (value)
                # (Line 173) }
                # (Line 176) }
            EUDEndIf()
            # (Line 177) GlobalDataLoadStatus[CP] = 1;
            EUDSetContinuePoint()
            _t11()
        EUDEndWhile()
        EUDTraceLog(177)
        _ARRW(GlobalDataLoadStatus, CP) << (1)
        # (Line 178) break;
        EUDTraceLog(178)
        EUDBreak()
        # (Line 179) }
    # (Line 180) }
    EUDEndSwitch()
    # (Line 183) function SaveDataWrite(){

@EUDTracedFunc
def SaveDataWrite():
    # (Line 184) const CP = getcurpl();
    EUDTraceLog(184)
    CP = f_getcurpl()
    # (Line 185) var index = 0;
    EUDTraceLog(185)
    index_1 = EUDVariable()
    index_1 << (0)
    # (Line 187) for(var i = 0 ; i < scf.ObjectCount; i++){
    EUDTraceLog(187)
    i = EUDVariable()
    i << (0)
    _t1 = EUDWhile()
    EUDTraceLog(187)
    if _t1(i >= scf.ObjectCount, neg=True):
        def _t2():
            EUDTraceLog(187)
            i.__iadd__(1)
        # (Line 188) index = scf.SaveDataWriteValue(i,BaseAddrEPD[CP],index);
        EUDTraceLog(188)
        index_1 << (scf.SaveDataWriteValue(i, BaseAddrEPD[CP], index_1))
        # (Line 210) }
        # (Line 211) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    EUDTraceLog(211)
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 212) index++;
    EUDTraceLog(212)
    index_1.__iadd__(1)
    # (Line 213) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
    EUDTraceLog(213)
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 214) index++;
    EUDTraceLog(214)
    index_1.__iadd__(1)
    # (Line 215) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
    EUDTraceLog(215)
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 216) index++;
    EUDTraceLog(216)
    index_1.__iadd__(1)
    # (Line 217) }
    # (Line 219) const CheckIntegrityFlag = PVariable();

CheckIntegrityFlag = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 220) function CheckIntegrity(){
@EUDTracedFunc
def CheckIntegrity():
    # (Line 221) const CP = getcurpl();
    EUDTraceLog(221)
    CP = f_getcurpl()
    # (Line 223) if (Memory(0x57F1B0,Exactly,CP)){
    _t1 = EUDIf()
    EUDTraceLog(223)
    if _t1(Memory(0x57F1B0, Exactly, CP)):
        # (Line 224) const BaseEPD = BaseAddrEPD[CP];
        EUDTraceLog(224)
        BaseEPD = BaseAddrEPD[CP]
        # (Line 225) const LoadEPD = LoadAddrEPD[CP];
        EUDTraceLog(225)
        LoadEPD = LoadAddrEPD[CP]
        # (Line 227) for(var i = 0 ; i < scf.SpaceLength / 4; i++){
        EUDTraceLog(227)
        i = EUDVariable()
        i << (0)
        _t2 = EUDWhile()
        EUDTraceLog(227)
        if _t2(i >= scf.SpaceLength // 4, neg=True):
            def _t3():
                EUDTraceLog(227)
                i.__iadd__(1)
            # (Line 228) const value1 = dwread_epd(BaseEPD + i);
            EUDTraceLog(228)
            value1 = f_dwread_epd(BaseEPD + i)
            # (Line 229) const value2 = dwread_epd(LoadEPD + i);
            EUDTraceLog(229)
            value2 = f_dwread_epd(LoadEPD + i)
            # (Line 233) if(MSQCSpecial == 0 && (value1 == 0 && value2 == 0)){
            _t4 = EUDIf()
            EUDTraceLog(233)
            if _t4(EUDSCAnd()(MSQCSpecial == 0)((EUDSCAnd()(value1 == 0)(value2 == 0)()))()):
                # (Line 234) MSQCSpecial = 3;
                EUDTraceLog(234)
                MSQCSpecial << (3)
                # (Line 235) }
                # (Line 237) if(MSQCSpecial == 0 && value1 != value2){
            EUDEndIf()
            _t5 = EUDIf()
            EUDTraceLog(237)
            if _t5(EUDSCAnd()(MSQCSpecial == 0)(value1 == value2, neg=True)()):
                # (Line 238) MSQCSpecial = 4;
                EUDTraceLog(238)
                MSQCSpecial << (4)
                # (Line 239) }
                # (Line 240) }
            EUDEndIf()
            # (Line 241) }
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        # (Line 242) }
    EUDEndIf()
    # (Line 245) function DataLoad();

# (Line 246) var TimeOut;
TimeOut = EUDVariable()
# (Line 248) var LastPing;
LastPing = EUDVariable()
# (Line 249) var DisConnectTimer;
DisConnectTimer = EUDVariable()
# (Line 250) var ConnectingTimer;
ConnectingTimer = EUDVariable()
# (Line 251) var ConnectingPoint;
ConnectingPoint = EUDVariable()
# (Line 252) function PlayerExec(){
@EUDTracedFunc
def PlayerExec():
    # (Line 253) const CP = getcurpl();
    EUDTraceLog(253)
    CP = f_getcurpl()
    # (Line 254) const CurrentTime = dwread_epd(EPD(0x51CE8C));
    EUDTraceLog(254)
    CurrentTime = f_dwread_epd(EPD(0x51CE8C))
    # (Line 255) const FrameTick = (LastTick - CurrentTime);
    EUDTraceLog(255)
    FrameTick = (LastTick - CurrentTime)
    # (Line 262) const Ping = wread_epd(EPD(scf.ws) + scf.EntryPointLength, 0);
    EUDTraceLog(262)
    Ping = f_wread_epd(EPD(scf.ws) + scf.EntryPointLength, 0)
    # (Line 263) if (Memory(0x57F1B0,Exactly,CP)){
    _t1 = EUDIf()
    EUDTraceLog(263)
    if _t1(Memory(0x57F1B0, Exactly, CP)):
        # (Line 264) if (LastPing != Ping){
        _t2 = EUDIf()
        EUDTraceLog(264)
        if _t2(LastPing == Ping, neg=True):
            # (Line 265) if (ConnectStatus[CP] == 0){
            _t3 = EUDIf()
            EUDTraceLog(265)
            if _t3(ConnectStatus[CP] == 0):
                # (Line 266) const CurrentConnectingTimer = (ConnectingTimer - CurrentTime);
                EUDTraceLog(266)
                CurrentConnectingTimer = (ConnectingTimer - CurrentTime)
                # (Line 267) if (CurrentConnectingTimer > 500){
                _t4 = EUDIf()
                EUDTraceLog(267)
                if _t4(CurrentConnectingTimer <= 500, neg=True):
                    # (Line 268) if (ConnectingPoint == 0){
                    _t5 = EUDIf()
                    EUDTraceLog(268)
                    if _t5(ConnectingPoint == 0):
                        # (Line 269) ConnectingTimer = CurrentTime;
                        EUDTraceLog(269)
                        ConnectingTimer << (CurrentTime)
                        # (Line 270) ConnectingPoint++;
                        EUDTraceLog(270)
                        ConnectingPoint.__iadd__(1)
                        # (Line 271) }else{
                    if EUDElse()():
                        # (Line 272) ConnectingTimer = 0;
                        EUDTraceLog(272)
                        ConnectingTimer << (0)
                        # (Line 273) MSQCSpecial = 1;
                        EUDTraceLog(273)
                        MSQCSpecial << (1)
                        # (Line 274) }
                        # (Line 275) }
                    EUDEndIf()
                    # (Line 276) }
                EUDEndIf()
                # (Line 278) LastPing = Ping;
            EUDEndIf()
            EUDTraceLog(278)
            LastPing << (Ping)
            # (Line 279) DisConnectTimer = CurrentTime;
            EUDTraceLog(279)
            DisConnectTimer << (CurrentTime)
            # (Line 280) }else{
        if EUDElse()():
            # (Line 281) if (ConnectStatus[CP] == 0){
            _t6 = EUDIf()
            EUDTraceLog(281)
            if _t6(ConnectStatus[CP] == 0):
                # (Line 282) const CurrentConnectingTimer = (ConnectingTimer - CurrentTime);
                EUDTraceLog(282)
                CurrentConnectingTimer = (ConnectingTimer - CurrentTime)
                # (Line 283) if (CurrentConnectingTimer > 1000){
                _t7 = EUDIf()
                EUDTraceLog(283)
                if _t7(CurrentConnectingTimer <= 1000, neg=True):
                    # (Line 284) ConnectingTimer = CurrentTime;
                    EUDTraceLog(284)
                    ConnectingTimer << (CurrentTime)
                    # (Line 285) ConnectingPoint = 0;
                    EUDTraceLog(285)
                    ConnectingPoint << (0)
                    # (Line 286) }
                    # (Line 287) }
                EUDEndIf()
                # (Line 288) }
            EUDEndIf()
            # (Line 289) }
        EUDEndIf()
        # (Line 294) if (ConnectStatus[CP] == 1){
    EUDEndIf()
    _t8 = EUDIf()
    EUDTraceLog(294)
    if _t8(ConnectStatus[CP] == 1):
        # (Line 295) if (Memory(0x57F1B0,Exactly,CP)){
        _t9 = EUDIf()
        EUDTraceLog(295)
        if _t9(Memory(0x57F1B0, Exactly, CP)):
            # (Line 296) const CurrentDisConnectTimer = (DisConnectTimer - CurrentTime);
            EUDTraceLog(296)
            CurrentDisConnectTimer = (DisConnectTimer - CurrentTime)
            # (Line 297) if (CurrentDisConnectTimer > 500){
            _t10 = EUDIf()
            EUDTraceLog(297)
            if _t10(CurrentDisConnectTimer <= 500, neg=True):
                # (Line 298) wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0);
                EUDTraceLog(298)
                f_wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0)
                # (Line 299) LastPing = 0;
                EUDTraceLog(299)
                LastPing << (0)
                # (Line 300) MSQCSpecial = 2;
                EUDTraceLog(300)
                MSQCSpecial << (2)
                # (Line 301) }
                # (Line 302) }
            EUDEndIf()
            # (Line 306) if(MSQCSpecialBuffer[CP] == 200){
        EUDEndIf()
        _t11 = EUDIf()
        EUDTraceLog(306)
        if _t11(MSQCSpecialBuffer[CP] == 200):
            # (Line 307) const orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength;
            EUDTraceLog(307)
            orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength
            # (Line 308) ConnectStatus[CP] = 0;
            EUDTraceLog(308)
            _ARRW(ConnectStatus, CP) << (0)
            # (Line 309) MSQCSpecialBuffer[CP] = 0;
            EUDTraceLog(309)
            _ARRW(MSQCSpecialBuffer, CP) << (0)
            # (Line 310) SCACommand[CP] = 0;
            EUDTraceLog(310)
            _ARRW(SCACommand, CP) << (0)
            # (Line 311) SCALastMessage[CP] = 2;
            EUDTraceLog(311)
            _ARRW(SCALastMessage, CP) << (2)
            # (Line 312) if (SCAUseUserMessage == 1){
            _t12 = EUDIf()
            EUDTraceLog(312)
            if _t12(SCAUseUserMessage == 1):
                # (Line 313) PlayWAV("sound\\Bullet\\tscFir00.wav");
                # (Line 314) f_eprintln("\x03SCArchive\x04와 \x07연결\x04이 \x08끊어졌습니다.");
                EUDTraceLog(313)
                DoActions(PlayWAV("sound\\Bullet\\tscFir00.wav"))
                EUDTraceLog(314)
                f_eprintln("\x03SCArchive\x04와 \x07연결\x04이 \x08끊어졌습니다.")
                # (Line 315) }
                # (Line 317) if (Memory(0x57F1B0,Exactly,CP)){
            EUDEndIf()
            _t13 = EUDIf()
            EUDTraceLog(317)
            if _t13(Memory(0x57F1B0, Exactly, CP)):
                # (Line 318) MSQCSpecial = 0;
                EUDTraceLog(318)
                MSQCSpecial << (0)
                # (Line 319) wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0);
                EUDTraceLog(319)
                f_wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0)
                # (Line 320) LastPing = 0;
                EUDTraceLog(320)
                LastPing << (0)
                # (Line 321) bwrite_epd(orderAddrEPD, 2, 0);
                EUDTraceLog(321)
                f_bwrite_epd(orderAddrEPD, 2, 0)
                # (Line 322) bwrite_epd(orderAddrEPD, 3, 0);
                EUDTraceLog(322)
                f_bwrite_epd(orderAddrEPD, 3, 0)
                # (Line 323) MSQCCondiction = 0;
                EUDTraceLog(323)
                MSQCCondiction << (0)
                # (Line 324) }
                # (Line 325) }
            EUDEndIf()
            # (Line 330) switch(SCACommand[CP]) {
        EUDEndIf()
        EUDTraceLog(330)
        EUDSwitch(SCACommand[CP])
        # (Line 331) case 1:
        _t14 = EUDSwitchCase()
        # (Line 332) case 2:
        EUDTraceLog(331)
        if _t14(1):
            pass
        _t15 = EUDSwitchCase()
        # (Line 333) case 3:
        EUDTraceLog(332)
        if _t15(2):
            pass
        _t16 = EUDSwitchCase()
        # (Line 334) const orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength;
        EUDTraceLog(333)
        if _t16(3):
            EUDTraceLog(334)
            orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength
            # (Line 335) if (Memory(0x57F1B0,Exactly,CP)){
            _t17 = EUDIf()
            EUDTraceLog(335)
            if _t17(Memory(0x57F1B0, Exactly, CP)):
                # (Line 337) bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP]);
                EUDTraceLog(337)
                f_bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP])
                # (Line 339) bwrite_epd(orderAddrEPD, 2, SCACommand[CP]);
                EUDTraceLog(339)
                f_bwrite_epd(orderAddrEPD, 2, SCACommand[CP])
                # (Line 340) }
                # (Line 345) const LauncherStatus = bread_epd(orderAddrEPD, 3);
            EUDEndIf()
            EUDTraceLog(345)
            LauncherStatus = f_bread_epd(orderAddrEPD, 3)
            # (Line 346) if (SCAUseUserMessage == 1){
            _t18 = EUDIf()
            EUDTraceLog(346)
            if _t18(SCAUseUserMessage == 1):
                # (Line 347) if(rn[CP] == 1){
                _t19 = EUDIf()
                EUDTraceLog(347)
                if _t19(rn[CP] == 1):
                    # (Line 348) f_eprintln("\x07불러오기 : \x03SCArchive\x04의 \x1F응답\x04을 \x07기다리는 중...");
                    EUDTraceLog(348)
                    f_eprintln("\x07불러오기 : \x03SCArchive\x04의 \x1F응답\x04을 \x07기다리는 중...")
                    # (Line 349) }else if(CheckIntegrityFlag[CP] == 0){
                _t20 = EUDElseIf()
                EUDTraceLog(349)
                if _t20(CheckIntegrityFlag[CP] == 0):
                    # (Line 350) f_eprintln("\x07불러오기 : \x03데이터 불러오는 중 ... \x1FPage : ", rn[CP]);
                    EUDTraceLog(350)
                    f_eprintln("\x07불러오기 : \x03데이터 불러오는 중 ... \x1FPage : ", rn[CP])
                    # (Line 351) }else if(CheckIntegrityFlag[CP] == 1){
                _t21 = EUDElseIf()
                EUDTraceLog(351)
                if _t21(CheckIntegrityFlag[CP] == 1):
                    # (Line 352) f_eprintln("\x07불러오기 : \x03전달 오류를 판단하는 중 ... ");
                    EUDTraceLog(352)
                    f_eprintln("\x07불러오기 : \x03전달 오류를 판단하는 중 ... ")
                    # (Line 353) }
                    # (Line 354) }
                EUDEndIf()
                # (Line 357) if(CheckIntegrityFlag[CP] == 0){
            EUDEndIf()
            _t22 = EUDIf()
            EUDTraceLog(357)
            if _t22(CheckIntegrityFlag[CP] == 0):
                # (Line 358) if (Memory(0x57F1B0,Exactly,CP)){
                _t23 = EUDIf()
                EUDTraceLog(358)
                if _t23(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 359) MSQCCondiction = 1;
                    EUDTraceLog(359)
                    MSQCCondiction << (1)
                    # (Line 360) }
                    # (Line 363) {const RecevieValue = ReceiveValue(MSQCBuffer[CP]);
                EUDEndIf()
                EUDTraceLog(363)
                RecevieValue = ReceiveValue(MSQCBuffer[CP])
                # (Line 365) if(ack[CP] == (rn[CP] % ackMax + 1)){
                _t24 = EUDIf()
                EUDTraceLog(365)
                if _t24(ack[CP] == (rn[CP] % ackMax + 1)):
                    # (Line 367) const rseq = rn[CP] - 1;
                    EUDTraceLog(367)
                    rseq = rn[CP] - 1
                    # (Line 368) wwrite_epd(LoadAddrEPD[CP] + rseq / 2, (rseq % 2) * 2, RecevieValue);
                    EUDTraceLog(368)
                    f_wwrite_epd(LoadAddrEPD[CP] + rseq // 2, (rseq % 2) * 2, RecevieValue)
                    # (Line 369) rn[CP] += 1;
                    EUDTraceLog(369)
                    _ARRW(rn, CP).__iadd__(1)
                    # (Line 370) }else if(ack[CP] == 0 && RecevieValue == 0xFFFF){
                _t25 = EUDElseIf()
                EUDTraceLog(370)
                if _t25(EUDSCAnd()(ack[CP] == 0)(RecevieValue == 0xFFFF)()):
                    # (Line 371) MaxBuffer[CP] = rn[CP] - 1;
                    EUDTraceLog(371)
                    _ARRW(MaxBuffer, CP) << (rn[CP] - 1)
                    # (Line 372) }else{
                if EUDElse()():
                    # (Line 373) const CurrentTimeer = (TimeOut - CurrentTime);
                    EUDTraceLog(373)
                    CurrentTimeer = (TimeOut - CurrentTime)
                    # (Line 374) if (CurrentTimeer > 500){
                    _t26 = EUDIf()
                    EUDTraceLog(374)
                    if _t26(CurrentTimeer <= 500, neg=True):
                        # (Line 375) TimeOut = CurrentTime;
                        EUDTraceLog(375)
                        TimeOut << (CurrentTime)
                        # (Line 376) index = rn[CP];
                        EUDTraceLog(376)
                        index << (rn[CP])
                        # (Line 377) }
                        # (Line 378) }}
                    EUDEndIf()
                EUDEndIf()
                # (Line 382) if(LauncherStatus == 1){
                _t27 = EUDIf()
                EUDTraceLog(382)
                if _t27(LauncherStatus == 1):
                    # (Line 383) const rseq = index - 1;
                    EUDTraceLog(383)
                    rseq = index - 1
                    # (Line 384) const CheckZero = dwread_epd(BaseAddrEPD[CP] + rseq / 2);
                    EUDTraceLog(384)
                    CheckZero = f_dwread_epd(BaseAddrEPD[CP] + rseq // 2)
                    # (Line 386) if (CheckZero == 0){
                    _t28 = EUDIf()
                    EUDTraceLog(386)
                    if _t28(CheckZero == 0):
                        # (Line 388) if (Memory(0x57F1B0,Exactly,CP)){
                        _t29 = EUDIf()
                        EUDTraceLog(388)
                        if _t29(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 389) MSQCValue = DisConnectCode % MapDim + (DisConnectCode / MapDim) * 0x10000;
                            EUDTraceLog(389)
                            MSQCValue << (DisConnectCode % MapDim + (DisConnectCode // MapDim) * 0x10000)
                            # (Line 390) }
                            # (Line 391) }else{
                        EUDEndIf()
                    if EUDElse()():
                        # (Line 392) SendValue(index);
                        EUDTraceLog(392)
                        SendValue(index)
                        # (Line 393) if (FrameTick > 70){
                        _t30 = EUDIf()
                        EUDTraceLog(393)
                        if _t30(FrameTick <= 70, neg=True):
                            # (Line 394) LastTick = CurrentTime;
                            EUDTraceLog(394)
                            LastTick << (CurrentTime)
                            # (Line 395) index += 1;
                            EUDTraceLog(395)
                            index.__iadd__(1)
                            # (Line 396) }
                            # (Line 397) }
                        EUDEndIf()
                        # (Line 398) }
                    EUDEndIf()
                    # (Line 399) }
                EUDEndIf()
                # (Line 404) {if (rn[CP] > MaxBuffer[CP]){
            EUDEndIf()
            _t31 = EUDIf()
            EUDTraceLog(404)
            if _t31(rn[CP] <= MaxBuffer[CP], neg=True):
                # (Line 405) const rseq = MaxBuffer[CP];
                EUDTraceLog(405)
                rseq = MaxBuffer[CP]
                # (Line 406) dwwrite_epd(LoadAddrEPD[CP] + rseq / 2, 0);
                EUDTraceLog(406)
                f_dwwrite_epd(LoadAddrEPD[CP] + rseq // 2, 0)
                # (Line 409) switch(CheckIntegrityFlag[CP]){
                EUDTraceLog(409)
                EUDSwitch(CheckIntegrityFlag[CP])
                # (Line 410) case 0:
                _t32 = EUDSwitchCase()
                # (Line 411) if (Memory(0x57F1B0,Exactly,CP)){
                EUDTraceLog(410)
                if _t32(0):
                    _t33 = EUDIf()
                    EUDTraceLog(411)
                    if _t33(Memory(0x57F1B0, Exactly, CP)):
                        # (Line 412) MSQCCondiction = 0;
                        EUDTraceLog(412)
                        MSQCCondiction << (0)
                        # (Line 413) }
                        # (Line 414) CheckIntegrity();
                    EUDEndIf()
                    EUDTraceLog(414)
                    CheckIntegrity()
                    # (Line 415) CheckIntegrityFlag[CP] = 1;
                    EUDTraceLog(415)
                    _ARRW(CheckIntegrityFlag, CP) << (1)
                    # (Line 416) break;
                    EUDTraceLog(416)
                    EUDBreak()
                    # (Line 417) case 1:
                _t34 = EUDSwitchCase()
                # (Line 418) CheckIntegrity();
                EUDTraceLog(417)
                if _t34(1):
                    EUDTraceLog(418)
                    CheckIntegrity()
                    # (Line 420) if(MSQCSpecialBuffer[CP] == 300){
                    _t35 = EUDIf()
                    EUDTraceLog(420)
                    if _t35(MSQCSpecialBuffer[CP] == 300):
                        # (Line 422) CheckIntegrityFlag[CP] = 2;
                        EUDTraceLog(422)
                        _ARRW(CheckIntegrityFlag, CP) << (2)
                        # (Line 423) MSQCSpecialBuffer[CP] = 0;
                        EUDTraceLog(423)
                        _ARRW(MSQCSpecialBuffer, CP) << (0)
                        # (Line 424) if (Memory(0x57F1B0,Exactly,CP)){
                        _t36 = EUDIf()
                        EUDTraceLog(424)
                        if _t36(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 425) MSQCSpecial = 0;
                            EUDTraceLog(425)
                            MSQCSpecial << (0)
                            # (Line 426) }
                            # (Line 427) }
                        EUDEndIf()
                        # (Line 428) if(MSQCSpecialBuffer[CP] == 400){
                    EUDEndIf()
                    _t37 = EUDIf()
                    EUDTraceLog(428)
                    if _t37(MSQCSpecialBuffer[CP] == 400):
                        # (Line 429) CheckIntegrityFlag[CP] = 0;
                        EUDTraceLog(429)
                        _ARRW(CheckIntegrityFlag, CP) << (0)
                        # (Line 430) MaxBuffer[CP] = scf.SpaceLength / 2;
                        EUDTraceLog(430)
                        _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
                        # (Line 431) rn[CP] = 1;
                        EUDTraceLog(431)
                        _ARRW(rn, CP) << (1)
                        # (Line 432) ack[CP] = 0;
                        EUDTraceLog(432)
                        _ARRW(ack, CP) << (0)
                        # (Line 433) if (Memory(0x57F1B0,Exactly,CP)){
                        _t38 = EUDIf()
                        EUDTraceLog(433)
                        if _t38(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 434) MSQCSpecial = 0;
                            EUDTraceLog(434)
                            MSQCSpecial << (0)
                            # (Line 435) index = 1;
                            EUDTraceLog(435)
                            index << (1)
                            # (Line 436) }
                            # (Line 437) }
                        EUDEndIf()
                        # (Line 438) break;
                    EUDEndIf()
                    EUDTraceLog(438)
                    EUDBreak()
                    # (Line 439) case 2:
                _t39 = EUDSwitchCase()
                # (Line 440) if (Memory(0x57F1B0,Exactly,CP)){
                EUDTraceLog(439)
                if _t39(2):
                    _t40 = EUDIf()
                    EUDTraceLog(440)
                    if _t40(Memory(0x57F1B0, Exactly, CP)):
                        # (Line 441) bwrite_epd(orderAddrEPD, 2, 0);
                        EUDTraceLog(441)
                        f_bwrite_epd(orderAddrEPD, 2, 0)
                        # (Line 442) bwrite_epd(orderAddrEPD, 3, 0);
                        EUDTraceLog(442)
                        f_bwrite_epd(orderAddrEPD, 3, 0)
                        # (Line 443) MSQCValue = 0;
                        EUDTraceLog(443)
                        MSQCValue << (0)
                        # (Line 444) MSQCCondiction = 0;
                        EUDTraceLog(444)
                        MSQCCondiction << (0)
                        # (Line 445) }
                        # (Line 446) LoadDataRead(rn[CP] - 1);
                    EUDEndIf()
                    EUDTraceLog(446)
                    LoadDataRead(rn[CP] - 1)
                    # (Line 447) SCACommand[CP] = 0;
                    EUDTraceLog(447)
                    _ARRW(SCACommand, CP) << (0)
                    # (Line 449) SCALastMessage[CP] = 4;
                    EUDTraceLog(449)
                    _ARRW(SCALastMessage, CP) << (4)
                    # (Line 450) if (SCAUseUserMessage == 1){
                    _t41 = EUDIf()
                    EUDTraceLog(450)
                    if _t41(SCAUseUserMessage == 1):
                        # (Line 451) PlayWAV("sound\\Misc\\TDrTra01.wav");
                        # (Line 452) f_eprintln("\x07성공적으로 \x03데이터\x04를 불러왔습니다.");
                        EUDTraceLog(451)
                        DoActions(PlayWAV("sound\\Misc\\TDrTra01.wav"))
                        EUDTraceLog(452)
                        f_eprintln("\x07성공적으로 \x03데이터\x04를 불러왔습니다.")
                        # (Line 453) }
                        # (Line 454) break;
                    EUDEndIf()
                    EUDTraceLog(454)
                    EUDBreak()
                    # (Line 455) }
                # (Line 456) }}
                EUDEndSwitch()
            EUDEndIf()
            # (Line 457) break;
            EUDTraceLog(457)
            EUDBreak()
            # (Line 458) case 4:
        _t42 = EUDSwitchCase()
        # (Line 459) if (Memory(0x57F1B0,Exactly,CP)){
        EUDTraceLog(458)
        if _t42(4):
            _t43 = EUDIf()
            EUDTraceLog(459)
            if _t43(Memory(0x57F1B0, Exactly, CP)):
                # (Line 461) bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP]);
                EUDTraceLog(461)
                f_bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP])
                # (Line 464) bwrite_epd(orderAddrEPD, 2, SCACommand[CP]);
                EUDTraceLog(464)
                f_bwrite_epd(orderAddrEPD, 2, SCACommand[CP])
                # (Line 466) }
                # (Line 471) const LauncherStatus2 = bread_epd(orderAddrEPD, 3);
            EUDEndIf()
            EUDTraceLog(471)
            LauncherStatus2 = f_bread_epd(orderAddrEPD, 3)
            # (Line 472) if(LauncherStatus2 == 1){
            _t44 = EUDIf()
            EUDTraceLog(472)
            if _t44(LauncherStatus2 == 1):
                # (Line 474) if (Memory(0x57F1B0,Exactly,CP)){
                _t45 = EUDIf()
                EUDTraceLog(474)
                if _t45(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 475) MSQCValue = 100;
                    EUDTraceLog(475)
                    MSQCValue << (100)
                    # (Line 476) MSQCCondiction = 1;
                    EUDTraceLog(476)
                    MSQCCondiction << (1)
                    # (Line 477) }
                    # (Line 478) }
                EUDEndIf()
                # (Line 479) if(MSQCBuffer[CP] == 100){
            EUDEndIf()
            _t46 = EUDIf()
            EUDTraceLog(479)
            if _t46(MSQCBuffer[CP] == 100):
                # (Line 480) if (Memory(0x57F1B0,Exactly,CP)){
                _t47 = EUDIf()
                EUDTraceLog(480)
                if _t47(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 481) bwrite_epd(orderAddrEPD, 2, 0);
                    EUDTraceLog(481)
                    f_bwrite_epd(orderAddrEPD, 2, 0)
                    # (Line 482) bwrite_epd(orderAddrEPD, 3, 0);
                    EUDTraceLog(482)
                    f_bwrite_epd(orderAddrEPD, 3, 0)
                    # (Line 483) MSQCValue = 0;
                    EUDTraceLog(483)
                    MSQCValue << (0)
                    # (Line 484) MSQCCondiction = 0;
                    EUDTraceLog(484)
                    MSQCCondiction << (0)
                    # (Line 485) }
                    # (Line 486) SCACommand[CP] = 0;
                EUDEndIf()
                EUDTraceLog(486)
                _ARRW(SCACommand, CP) << (0)
                # (Line 488) SCALastMessage[CP] = 6;
                EUDTraceLog(488)
                _ARRW(SCALastMessage, CP) << (6)
                # (Line 489) if (SCAUseUserMessage == 1){
                _t48 = EUDIf()
                EUDTraceLog(489)
                if _t48(SCAUseUserMessage == 1):
                    # (Line 490) PlayWAV("sound\\Misc\\TDrTra01.wav");
                    # (Line 491) f_eprintln("\x07성공적으로 \x03데이터\x04를 저장했습니다.");
                    EUDTraceLog(490)
                    DoActions(PlayWAV("sound\\Misc\\TDrTra01.wav"))
                    EUDTraceLog(491)
                    f_eprintln("\x07성공적으로 \x03데이터\x04를 저장했습니다.")
                    # (Line 492) }
                    # (Line 493) }
                EUDEndIf()
                # (Line 494) break;
            EUDEndIf()
            EUDTraceLog(494)
            EUDBreak()
            # (Line 495) }
        # (Line 496) }else{
        EUDEndSwitch()
    if EUDElse()():
        # (Line 497) if(MSQCSpecialBuffer[CP] == 100){
        _t49 = EUDIf()
        EUDTraceLog(497)
        if _t49(MSQCSpecialBuffer[CP] == 100):
            # (Line 498) ConnectStatus[CP] = 1;
            EUDTraceLog(498)
            _ARRW(ConnectStatus, CP) << (1)
            # (Line 499) MSQCSpecialBuffer[CP] = 0;
            EUDTraceLog(499)
            _ARRW(MSQCSpecialBuffer, CP) << (0)
            # (Line 500) SCALastMessage[CP] = 1;
            EUDTraceLog(500)
            _ARRW(SCALastMessage, CP) << (1)
            # (Line 501) if (SCAUseUserMessage == 1){
            _t50 = EUDIf()
            EUDTraceLog(501)
            if _t50(SCAUseUserMessage == 1):
                # (Line 502) PlayWAV("sound\\Misc\\ZRescue.wav");
                # (Line 503) f_eprintln("\x03SCArchive\x04와 \x07연결\x04되었습니다.");
                EUDTraceLog(502)
                DoActions(PlayWAV("sound\\Misc\\ZRescue.wav"))
                EUDTraceLog(503)
                f_eprintln("\x03SCArchive\x04와 \x07연결\x04되었습니다.")
                # (Line 504) }
                # (Line 505) if (Memory(0x57F1B0,Exactly,CP)){
            EUDEndIf()
            _t51 = EUDIf()
            EUDTraceLog(505)
            if _t51(Memory(0x57F1B0, Exactly, CP)):
                # (Line 506) MSQCSpecial = 0;
                EUDTraceLog(506)
                MSQCSpecial << (0)
                # (Line 507) }
                # (Line 508) }
            EUDEndIf()
            # (Line 509) }
        EUDEndIf()
        # (Line 514) }
    EUDEndIf()
    # (Line 516) function Exec(){

@EUDTracedFunc
def Exec():
    # (Line 517) EUDPlayerLoop()();
    EUDTraceLog(517)
    EUDPlayerLoop()()
    # (Line 518) PlayerExec();
    EUDTraceLog(518)
    PlayerExec()
    # (Line 519) EUDEndPlayerLoop();
    EUDTraceLog(519)
    EUDEndPlayerLoop()
    # (Line 520) }
    # (Line 523) function DataLoad(Slot){

@EUDTracedFunc
def DataLoad(Slot):
    # (Line 524) const CP = getcurpl();
    EUDTraceLog(524)
    CP = f_getcurpl()
    # (Line 526) if (ConnectStatus[CP] == 1){
    _t1 = EUDIf()
    EUDTraceLog(526)
    if _t1(ConnectStatus[CP] == 1):
        # (Line 527) if (SCACommand[CP] == 0){
        _t2 = EUDIf()
        EUDTraceLog(527)
        if _t2(SCACommand[CP] == 0):
            # (Line 528) DataSlot[CP] = Slot;
            EUDTraceLog(528)
            _ARRW(DataSlot, CP) << (Slot)
            # (Line 529) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            EUDTraceLog(529)
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 530) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            EUDTraceLog(530)
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 533) LastTick = dwread_epd(EPD(0x51CE8C));
            EUDTraceLog(533)
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 535) SCALastMessage[CP] = 3;
            EUDTraceLog(535)
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 536) if (SCAUseUserMessage == 1){
            _t3 = EUDIf()
            EUDTraceLog(536)
            if _t3(SCAUseUserMessage == 1):
                # (Line 537) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 538) }
                EUDTraceLog(537)
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 539) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            EUDTraceLog(539)
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 540) MaxBuffer[CP] = scf.SpaceLength / 2;
            EUDTraceLog(540)
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 541) rn[CP] = 1;
            EUDTraceLog(541)
            _ARRW(rn, CP) << (1)
            # (Line 542) ack[CP] = 0;
            EUDTraceLog(542)
            _ARRW(ack, CP) << (0)
            # (Line 543) if (Memory(0x57F1B0,Exactly,CP)){
            _t4 = EUDIf()
            EUDTraceLog(543)
            if _t4(Memory(0x57F1B0, Exactly, CP)):
                # (Line 544) MSQCValue = 0;
                EUDTraceLog(544)
                MSQCValue << (0)
                # (Line 545) index = 1;
                EUDTraceLog(545)
                index << (1)
                # (Line 546) }
                # (Line 547) SCACommand[CP] = 1;
            EUDEndIf()
            EUDTraceLog(547)
            _ARRW(SCACommand, CP) << (1)
            # (Line 548) MSQCBuffer[CP] = 0;
            EUDTraceLog(548)
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 549) }else{
        if EUDElse()():
            # (Line 550) SCALastMessage[CP] = 8;
            EUDTraceLog(550)
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 551) if (SCAUseUserMessage == 1){
            _t5 = EUDIf()
            EUDTraceLog(551)
            if _t5(SCAUseUserMessage == 1):
                # (Line 552) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 553) f_eprintln("\x08현재 다른 작업중입니다.");
                EUDTraceLog(552)
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                EUDTraceLog(553)
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 554) }
                # (Line 555) }
            EUDEndIf()
            # (Line 556) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 557) SCALastMessage[CP] = 7;
        EUDTraceLog(557)
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 558) if (SCAUseUserMessage == 1){
        _t6 = EUDIf()
        EUDTraceLog(558)
        if _t6(SCAUseUserMessage == 1):
            # (Line 559) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 560) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            EUDTraceLog(559)
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            EUDTraceLog(560)
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 561) }
            # (Line 562) }
        EUDEndIf()
        # (Line 563) }
    EUDEndIf()
    # (Line 566) function DataSave(Slot){

@EUDTracedFunc
def DataSave(Slot):
    # (Line 567) const CP = getcurpl();
    EUDTraceLog(567)
    CP = f_getcurpl()
    # (Line 569) if (ConnectStatus[CP] == 1){
    _t1 = EUDIf()
    EUDTraceLog(569)
    if _t1(ConnectStatus[CP] == 1):
        # (Line 570) if (SCACommand[CP] == 0){
        _t2 = EUDIf()
        EUDTraceLog(570)
        if _t2(SCACommand[CP] == 0):
            # (Line 571) DataSlot[CP] = Slot;
            EUDTraceLog(571)
            _ARRW(DataSlot, CP) << (Slot)
            # (Line 572) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            EUDTraceLog(572)
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 574) if (Memory(0x57F1B0,Exactly,CP)){
            _t3 = EUDIf()
            EUDTraceLog(574)
            if _t3(Memory(0x57F1B0, Exactly, CP)):
                # (Line 575) SaveDataWrite();
                EUDTraceLog(575)
                SaveDataWrite()
                # (Line 576) }
                # (Line 578) MSQCBuffer[CP] = 0;
            EUDEndIf()
            EUDTraceLog(578)
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 579) SCALastMessage[CP] = 5;
            EUDTraceLog(579)
            _ARRW(SCALastMessage, CP) << (5)
            # (Line 580) if (SCAUseUserMessage == 1){
            _t4 = EUDIf()
            EUDTraceLog(580)
            if _t4(SCAUseUserMessage == 1):
                # (Line 581) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 582) }
                EUDTraceLog(581)
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 584) SCACommand[CP] = 4;
            EUDEndIf()
            EUDTraceLog(584)
            _ARRW(SCACommand, CP) << (4)
            # (Line 585) }else{
        if EUDElse()():
            # (Line 586) SCALastMessage[CP] = 8;
            EUDTraceLog(586)
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 587) if (SCAUseUserMessage == 1){
            _t5 = EUDIf()
            EUDTraceLog(587)
            if _t5(SCAUseUserMessage == 1):
                # (Line 588) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 589) f_eprintln("\x08현재 다른 작업중입니다.");
                EUDTraceLog(588)
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                EUDTraceLog(589)
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 590) }
                # (Line 591) }
            EUDEndIf()
            # (Line 592) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 593) SCALastMessage[CP] = 7;
        EUDTraceLog(593)
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 594) if (SCAUseUserMessage == 1){
        _t6 = EUDIf()
        EUDTraceLog(594)
        if _t6(SCAUseUserMessage == 1):
            # (Line 595) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 596) f_eprintln("\x08데이터를 저장하기 위해선 SCArchive와 연결되어야 합니다.");
            EUDTraceLog(595)
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            EUDTraceLog(596)
            f_eprintln("\x08데이터를 저장하기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 597) }
            # (Line 598) }
        EUDEndIf()
        # (Line 599) }
    EUDEndIf()
    # (Line 603) function GetDate(){

@EUDTracedFunc
def GetDate():
    # (Line 604) const CP = getcurpl();
    EUDTraceLog(604)
    CP = f_getcurpl()
    # (Line 605) if (ConnectStatus[CP] == 1){
    _t1 = EUDIf()
    EUDTraceLog(605)
    if _t1(ConnectStatus[CP] == 1):
        # (Line 606) if (SCACommand[CP] == 0){
        _t2 = EUDIf()
        EUDTraceLog(606)
        if _t2(SCACommand[CP] == 0):
            # (Line 607) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            EUDTraceLog(607)
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 608) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            EUDTraceLog(608)
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 611) LastTick = dwread_epd(EPD(0x51CE8C));
            EUDTraceLog(611)
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 613) SCALastMessage[CP] = 3;
            EUDTraceLog(613)
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 614) if (SCAUseUserMessage == 1){
            _t3 = EUDIf()
            EUDTraceLog(614)
            if _t3(SCAUseUserMessage == 1):
                # (Line 615) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 616) }
                EUDTraceLog(615)
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 617) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            EUDTraceLog(617)
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 618) MaxBuffer[CP] = scf.SpaceLength / 2;
            EUDTraceLog(618)
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 619) rn[CP] = 1;
            EUDTraceLog(619)
            _ARRW(rn, CP) << (1)
            # (Line 620) ack[CP] = 0;
            EUDTraceLog(620)
            _ARRW(ack, CP) << (0)
            # (Line 621) if (Memory(0x57F1B0,Exactly,CP)){
            _t4 = EUDIf()
            EUDTraceLog(621)
            if _t4(Memory(0x57F1B0, Exactly, CP)):
                # (Line 622) MSQCValue = 0;
                EUDTraceLog(622)
                MSQCValue << (0)
                # (Line 623) index = 1;
                EUDTraceLog(623)
                index << (1)
                # (Line 624) }
                # (Line 625) SCACommand[CP] = 2;
            EUDEndIf()
            EUDTraceLog(625)
            _ARRW(SCACommand, CP) << (2)
            # (Line 626) MSQCBuffer[CP] = 0;
            EUDTraceLog(626)
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 627) }else{
        if EUDElse()():
            # (Line 628) SCALastMessage[CP] = 8;
            EUDTraceLog(628)
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 629) if (SCAUseUserMessage == 1){
            _t5 = EUDIf()
            EUDTraceLog(629)
            if _t5(SCAUseUserMessage == 1):
                # (Line 630) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 631) f_eprintln("\x08현재 다른 작업중입니다.");
                EUDTraceLog(630)
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                EUDTraceLog(631)
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 632) }
                # (Line 633) }
            EUDEndIf()
            # (Line 634) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 635) SCALastMessage[CP] = 7;
        EUDTraceLog(635)
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 636) if (SCAUseUserMessage == 1){
        _t6 = EUDIf()
        EUDTraceLog(636)
        if _t6(SCAUseUserMessage == 1):
            # (Line 637) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 638) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            EUDTraceLog(637)
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            EUDTraceLog(638)
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 639) }
            # (Line 640) }
        EUDEndIf()
        # (Line 641) }
    EUDEndIf()
    # (Line 644) function LoadGlobalData(){

@EUDTracedFunc
def LoadGlobalData():
    # (Line 645) const CP = getcurpl();
    EUDTraceLog(645)
    CP = f_getcurpl()
    # (Line 646) if (ConnectStatus[CP] == 1){
    _t1 = EUDIf()
    EUDTraceLog(646)
    if _t1(ConnectStatus[CP] == 1):
        # (Line 647) if (SCACommand[CP] == 0){
        _t2 = EUDIf()
        EUDTraceLog(647)
        if _t2(SCACommand[CP] == 0):
            # (Line 648) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            EUDTraceLog(648)
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 649) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            EUDTraceLog(649)
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 652) LastTick = dwread_epd(EPD(0x51CE8C));
            EUDTraceLog(652)
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 654) SCALastMessage[CP] = 3;
            EUDTraceLog(654)
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 655) if (SCAUseUserMessage == 1){
            _t3 = EUDIf()
            EUDTraceLog(655)
            if _t3(SCAUseUserMessage == 1):
                # (Line 656) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 657) }
                EUDTraceLog(656)
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 658) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            EUDTraceLog(658)
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 659) MaxBuffer[CP] = scf.SpaceLength / 2;
            EUDTraceLog(659)
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 660) rn[CP] = 1;
            EUDTraceLog(660)
            _ARRW(rn, CP) << (1)
            # (Line 661) ack[CP] = 0;
            EUDTraceLog(661)
            _ARRW(ack, CP) << (0)
            # (Line 662) if (Memory(0x57F1B0,Exactly,CP)){
            _t4 = EUDIf()
            EUDTraceLog(662)
            if _t4(Memory(0x57F1B0, Exactly, CP)):
                # (Line 663) MSQCValue = 0;
                EUDTraceLog(663)
                MSQCValue << (0)
                # (Line 664) index = 1;
                EUDTraceLog(664)
                index << (1)
                # (Line 665) }
                # (Line 666) SCACommand[CP] = 3;
            EUDEndIf()
            EUDTraceLog(666)
            _ARRW(SCACommand, CP) << (3)
            # (Line 667) MSQCBuffer[CP] = 0;
            EUDTraceLog(667)
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 668) }else{
        if EUDElse()():
            # (Line 669) SCALastMessage[CP] = 8;
            EUDTraceLog(669)
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 670) if (SCAUseUserMessage == 1){
            _t5 = EUDIf()
            EUDTraceLog(670)
            if _t5(SCAUseUserMessage == 1):
                # (Line 671) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 672) f_eprintln("\x08현재 다른 작업중입니다.");
                EUDTraceLog(671)
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                EUDTraceLog(672)
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 673) }
                # (Line 674) }
            EUDEndIf()
            # (Line 675) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 676) SCALastMessage[CP] = 7;
        EUDTraceLog(676)
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 677) if (SCAUseUserMessage == 1){
        _t6 = EUDIf()
        EUDTraceLog(677)
        if _t6(SCAUseUserMessage == 1):
            # (Line 678) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 679) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            EUDTraceLog(678)
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            EUDTraceLog(679)
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 680) }
            # (Line 681) }
        EUDEndIf()
        # (Line 682) }
    EUDEndIf()
