## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import SCAFlexible as scf;
import SCAFlexible as scf
# (Line 2) import SCArchive as sca;
import SCArchive as sca
# (Line 4) const CommandLength = 12;
CommandLength = _CGFW(lambda: [12], 1)[0]
# (Line 9) const ackMax = 0x20;
ackMax = _CGFW(lambda: [0x20], 1)[0]
# (Line 10) const MapDim = 0x600;
MapDim = _CGFW(lambda: [0x600], 1)[0]
# (Line 11) var DisConnectCode = 0xFFFF;
DisConnectCode = EUDCreateVariables(1)
_IGVA([DisConnectCode], lambda: [0xFFFF])
# (Line 14) var MSQCSpecial = 0;
MSQCSpecial = EUDCreateVariables(1)
_IGVA([MSQCSpecial], lambda: [0])
# (Line 15) var MSQCCondiction = 0;
MSQCCondiction = EUDCreateVariables(1)
_IGVA([MSQCCondiction], lambda: [0])
# (Line 16) var MSQCValue = 0;
MSQCValue = EUDCreateVariables(1)
_IGVA([MSQCValue], lambda: [0])
# (Line 18) const MSQCSpecialBuffer = PVariable();
MSQCSpecialBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 19) const MSQCBuffer = PVariable();
MSQCBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 21) function Init(){
@EUDFunc
def Init():
    # (Line 22) EUDRegisterObjectToNamespace("MSQCSpecial", MSQCSpecial);
    EUDRegisterObjectToNamespace("MSQCSpecial", MSQCSpecial)
    # (Line 23) EUDRegisterObjectToNamespace("MSQCSpecialBuffer", MSQCSpecialBuffer);
    EUDRegisterObjectToNamespace("MSQCSpecialBuffer", MSQCSpecialBuffer)
    # (Line 24) EUDRegisterObjectToNamespace("MSQCCondiction", MSQCCondiction);
    EUDRegisterObjectToNamespace("MSQCCondiction", MSQCCondiction)
    # (Line 25) EUDRegisterObjectToNamespace("MSQCValue", MSQCValue);
    EUDRegisterObjectToNamespace("MSQCValue", MSQCValue)
    # (Line 26) EUDRegisterObjectToNamespace("MSQCBuffer", MSQCBuffer);
    EUDRegisterObjectToNamespace("MSQCBuffer", MSQCBuffer)
    # (Line 27) }
    # (Line 30) var SCAUseUserMessage = 1;

SCAUseUserMessage = EUDCreateVariables(1)
_IGVA([SCAUseUserMessage], lambda: [1])
# (Line 31) const SCALastMessage = PVariable();
SCALastMessage = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 48) var LastTick;
LastTick = EUDVariable()
# (Line 51) const ConnectStatus = PVariable();
ConnectStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 52) const MaxBuffer = PVariable();
MaxBuffer = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 53) const BaseAddrEPD = PVariable();
BaseAddrEPD = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 54) const LoadAddrEPD = PVariable();
LoadAddrEPD = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 55) var index;
index = EUDVariable()
# (Line 56) const rn = PVariable();
rn = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 57) const ack = PVariable();
ack = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 58) const SCACommand = PVariable();
SCACommand = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 59) const DataSlot = PVariable();
DataSlot = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 60) function ReceiveValue(value){
@EUDFunc
def ReceiveValue(value):
    # (Line 61) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 62) value = value % 0x10000 + (value / 0x10000) * MapDim;
    value << (value % 0x10000 + (value // 0x10000) * MapDim)
    # (Line 63) ack[CP] = value / 0x10000;
    _ARRW(ack, CP) << (value // 0x10000)
    # (Line 64) value = value % 0x10000;
    value << (value % 0x10000)
    # (Line 65) return value;
    EUDReturn(value)
    # (Line 66) }
    # (Line 68) function SendValue(seq){

@EUDFunc
def SendValue(seq):
    # (Line 69) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 70) const rseq = seq - 1;
    rseq = seq - 1
    # (Line 71) var value = wread_epd(BaseAddrEPD[CP] + rseq / 2, (rseq % 2) * 2);
    value = EUDVariable()
    value << (f_wread_epd(BaseAddrEPD[CP] + rseq // 2, (rseq % 2) * 2))
    # (Line 73) seq = seq % ackMax + 1;
    seq << (seq % ackMax + 1)
    # (Line 74) value += seq * 0x10000;
    value.__iadd__(seq * 0x10000)
    # (Line 76) if (Memory(0x57F1B0,Exactly,CP)){
    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
        # (Line 77) MSQCValue = value % MapDim + (value / MapDim) * 0x10000;
        MSQCValue << (value % MapDim + (value // MapDim) * 0x10000)
        # (Line 78) }
        # (Line 79) }
    EUDEndIf()
    # (Line 85) const DateLoadStatus = PVariable();

DateLoadStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 86) const GlobalDataLoadStatus = PVariable();
GlobalDataLoadStatus = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 91) function LoadDataRead(dataLen){
@EUDFunc
def LoadDataRead(dataLen):
    # (Line 92) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 94) switch(SCACommand[CP]){
    EUDSwitch(SCACommand[CP])
    # (Line 95) case 1:
    _t1 = EUDSwitchCase()
    # (Line 96) for(var i = 0 ; i < scf.ObjectCount; i++){
    if _t1(1):
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= scf.ObjectCount, neg=True):
            def _t3():
                i.__iadd__(1)
            # (Line 97) scf.ResetValue(i, 0);
            scf.ResetValue(i, 0)
            # (Line 98) }
            # (Line 100) for(var i = 0 ; i < dataLen; i++){
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= dataLen, neg=True):
            def _t5():
                i.__iadd__(1)
            # (Line 101) i = scf.LoadDataReadValue(LoadAddrEPD[CP], i);
            i << (scf.LoadDataReadValue(LoadAddrEPD[CP], i))
            # (Line 129) }
            # (Line 130) break;
            EUDSetContinuePoint()
            _t5()
        EUDEndWhile()
        EUDBreak()
        # (Line 131) case 2:
    _t6 = EUDSwitchCase()
    # (Line 133) const BaseAddres = LoadAddrEPD[CP];
    if _t6(2):
        BaseAddres = LoadAddrEPD[CP]
        # (Line 135) const aYM = dwread_epd(BaseAddres);
        aYM = f_dwread_epd(BaseAddres)
        # (Line 136) sca.Year = aYM / 0x10;
        _ATTW(sca, 'Year') << (aYM // 0x10)
        # (Line 137) sca.Month = aYM % 0x10;
        _ATTW(sca, 'Month') << (aYM % 0x10)
        # (Line 139) sca.Day = bread_epd(BaseAddres + 1, 3);
        _ATTW(sca, 'Day') << (f_bread_epd(BaseAddres + 1, 3))
        # (Line 140) sca.Hour = bread_epd(BaseAddres +1, 2);
        _ATTW(sca, 'Hour') << (f_bread_epd(BaseAddres + 1, 2))
        # (Line 141) sca.Min = bread_epd(BaseAddres + 1, 1);
        _ATTW(sca, 'Min') << (f_bread_epd(BaseAddres + 1, 1))
        # (Line 142) sca.Week = bread_epd(BaseAddres + 1 , 0);
        _ATTW(sca, 'Week') << (f_bread_epd(BaseAddres + 1, 0))
        # (Line 144) DateLoadStatus[CP] = 1;
        _ARRW(DateLoadStatus, CP) << (1)
        # (Line 145) break;
        EUDBreak()
        # (Line 146) case 3:
    _t7 = EUDSwitchCase()
    # (Line 148) var value = 0;
    if _t7(3):
        value = EUDVariable()
        value << (0)
        # (Line 150) for(var i = 0 ; i < 20; i++){
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= 20, neg=True):
            def _t9():
                i.__iadd__(1)
            # (Line 151) sca.GlobalData[i] = 0;
            _ARRW(sca.GlobalData, i) << (0)
            # (Line 152) }
            # (Line 154) for(var i = 0 ; i < dataLen; i++){
            EUDSetContinuePoint()
            _t9()
        EUDEndWhile()
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= dataLen, neg=True):
            def _t11():
                i.__iadd__(1)
            # (Line 155) const insepector = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
            insepector = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
            # (Line 156) if (insepector != 0){
            if EUDIf()(insepector == 0, neg=True):
                # (Line 157) const vsize = insepector / 0x100;
                vsize = insepector // 0x100
                # (Line 158) const index = insepector % 0x100;
                index_1 = insepector % 0x100
                # (Line 161) if (vsize == 1){
                if EUDIf()(vsize == 1):
                    # (Line 162) i++;
                    i.__iadd__(1)
                    # (Line 163) const value1 = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    value1 = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
                    # (Line 164) i++;
                    i.__iadd__(1)
                    # (Line 165) const value2 = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    value2 = f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2)
                    # (Line 166) value = value1 * 0x10000 + value2;
                    value << (value1 * 0x10000 + value2)
                    # (Line 167) }else if(vsize == 2){
                if EUDElseIf()(vsize == 2):
                    # (Line 168) i++;
                    i.__iadd__(1)
                    # (Line 169) value = wread_epd(LoadAddrEPD[CP] + i / 2, (i % 2) * 2);
                    value << (f_wread_epd(LoadAddrEPD[CP] + i // 2, (i % 2) * 2))
                    # (Line 170) }
                    # (Line 172) sca.GlobalData[index] = value;
                EUDEndIf()
                _ARRW(sca.GlobalData, index_1) << (value)
                # (Line 173) }
                # (Line 176) }
            EUDEndIf()
            # (Line 177) GlobalDataLoadStatus[CP] = 1;
            EUDSetContinuePoint()
            _t11()
        EUDEndWhile()
        _ARRW(GlobalDataLoadStatus, CP) << (1)
        # (Line 178) break;
        EUDBreak()
        # (Line 179) }
    # (Line 180) }
    EUDEndSwitch()
    # (Line 183) function SaveDataWrite(){

@EUDFunc
def SaveDataWrite():
    # (Line 184) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 185) var index = 0;
    index_1 = EUDVariable()
    index_1 << (0)
    # (Line 187) for(var i = 0 ; i < scf.ObjectCount; i++){
    i = EUDVariable()
    i << (0)
    if EUDWhile()(i >= scf.ObjectCount, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 188) index = scf.SaveDataWriteValue(i,BaseAddrEPD[CP],index);
        index_1 << (scf.SaveDataWriteValue(i, BaseAddrEPD[CP], index_1))
        # (Line 210) }
        # (Line 211) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 212) index++;
    index_1.__iadd__(1)
    # (Line 213) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 214) index++;
    index_1.__iadd__(1)
    # (Line 215) wwrite_epd(BaseAddrEPD[CP] + index / 2, (index % 2) * 2, 0);
    f_wwrite_epd(BaseAddrEPD[CP] + index_1 // 2, (index_1 % 2) * 2, 0)
    # (Line 216) index++;
    index_1.__iadd__(1)
    # (Line 217) }
    # (Line 219) const CheckIntegrityFlag = PVariable();

CheckIntegrityFlag = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 220) function CheckIntegrity(){
@EUDFunc
def CheckIntegrity():
    # (Line 221) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 223) if (Memory(0x57F1B0,Exactly,CP)){
    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
        # (Line 224) const BaseEPD = BaseAddrEPD[CP];
        BaseEPD = BaseAddrEPD[CP]
        # (Line 225) const LoadEPD = LoadAddrEPD[CP];
        LoadEPD = LoadAddrEPD[CP]
        # (Line 227) for(var i = 0 ; i < scf.SpaceLength / 4; i++){
        i = EUDVariable()
        i << (0)
        if EUDWhile()(i >= scf.SpaceLength // 4, neg=True):
            def _t3():
                i.__iadd__(1)
            # (Line 228) const value1 = dwread_epd(BaseEPD + i);
            value1 = f_dwread_epd(BaseEPD + i)
            # (Line 229) const value2 = dwread_epd(LoadEPD + i);
            value2 = f_dwread_epd(LoadEPD + i)
            # (Line 233) if(MSQCSpecial == 0 && (value1 == 0 && value2 == 0)){
            if EUDIf()(EUDSCAnd()(MSQCSpecial == 0)((EUDSCAnd()(value1 == 0)(value2 == 0)()))()):
                # (Line 234) MSQCSpecial = 3;
                MSQCSpecial << (3)
                # (Line 235) }
                # (Line 237) if(MSQCSpecial == 0 && value1 != value2){
            EUDEndIf()
            if EUDIf()(EUDSCAnd()(MSQCSpecial == 0)(value1 == value2, neg=True)()):
                # (Line 238) MSQCSpecial = 4;
                MSQCSpecial << (4)
                # (Line 239) }
                # (Line 240) }
            EUDEndIf()
            # (Line 241) }
            EUDSetContinuePoint()
            _t3()
        EUDEndWhile()
        # (Line 242) }
    EUDEndIf()
    # (Line 245) function DataLoad();

# (Line 246) var TimeOut;
TimeOut = EUDVariable()
# (Line 248) var LastPing;
LastPing = EUDVariable()
# (Line 249) var DisConnectTimer;
DisConnectTimer = EUDVariable()
# (Line 250) var ConnectingTimer;
ConnectingTimer = EUDVariable()
# (Line 251) var ConnectingPoint;
ConnectingPoint = EUDVariable()
# (Line 252) function PlayerExec(){
@EUDFunc
def PlayerExec():
    # (Line 253) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 254) const CurrentTime = dwread_epd(EPD(0x51CE8C));
    CurrentTime = f_dwread_epd(EPD(0x51CE8C))
    # (Line 255) const FrameTick = (LastTick - CurrentTime);
    FrameTick = (LastTick - CurrentTime)
    # (Line 262) const Ping = wread_epd(EPD(scf.ws) + scf.EntryPointLength, 0);
    Ping = f_wread_epd(EPD(scf.ws) + scf.EntryPointLength, 0)
    # (Line 263) if (Memory(0x57F1B0,Exactly,CP)){
    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
        # (Line 264) if (LastPing != Ping){
        if EUDIf()(LastPing == Ping, neg=True):
            # (Line 265) if (ConnectStatus[CP] == 0){
            if EUDIf()(ConnectStatus[CP] == 0):
                # (Line 266) const CurrentConnectingTimer = (ConnectingTimer - CurrentTime);
                CurrentConnectingTimer = (ConnectingTimer - CurrentTime)
                # (Line 267) if (CurrentConnectingTimer > 500){
                if EUDIf()(CurrentConnectingTimer <= 500, neg=True):
                    # (Line 268) if (ConnectingPoint == 0){
                    if EUDIf()(ConnectingPoint == 0):
                        # (Line 269) ConnectingTimer = CurrentTime;
                        ConnectingTimer << (CurrentTime)
                        # (Line 270) ConnectingPoint++;
                        ConnectingPoint.__iadd__(1)
                        # (Line 271) }else{
                    if EUDElse()():
                        # (Line 272) ConnectingTimer = 0;
                        ConnectingTimer << (0)
                        # (Line 273) MSQCSpecial = 1;
                        MSQCSpecial << (1)
                        # (Line 274) }
                        # (Line 275) }
                    EUDEndIf()
                    # (Line 276) }
                EUDEndIf()
                # (Line 278) LastPing = Ping;
            EUDEndIf()
            LastPing << (Ping)
            # (Line 279) DisConnectTimer = CurrentTime;
            DisConnectTimer << (CurrentTime)
            # (Line 280) }else{
        if EUDElse()():
            # (Line 281) if (ConnectStatus[CP] == 0){
            if EUDIf()(ConnectStatus[CP] == 0):
                # (Line 282) const CurrentConnectingTimer = (ConnectingTimer - CurrentTime);
                CurrentConnectingTimer = (ConnectingTimer - CurrentTime)
                # (Line 283) if (CurrentConnectingTimer > 1000){
                if EUDIf()(CurrentConnectingTimer <= 1000, neg=True):
                    # (Line 284) ConnectingTimer = CurrentTime;
                    ConnectingTimer << (CurrentTime)
                    # (Line 285) ConnectingPoint = 0;
                    ConnectingPoint << (0)
                    # (Line 286) }
                    # (Line 287) }
                EUDEndIf()
                # (Line 288) }
            EUDEndIf()
            # (Line 289) }
        EUDEndIf()
        # (Line 294) if (ConnectStatus[CP] == 1){
    EUDEndIf()
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 295) if (Memory(0x57F1B0,Exactly,CP)){
        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
            # (Line 296) const CurrentDisConnectTimer = (DisConnectTimer - CurrentTime);
            CurrentDisConnectTimer = (DisConnectTimer - CurrentTime)
            # (Line 297) if (CurrentDisConnectTimer > 500){
            if EUDIf()(CurrentDisConnectTimer <= 500, neg=True):
                # (Line 298) wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0);
                f_wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0)
                # (Line 299) LastPing = 0;
                LastPing << (0)
                # (Line 300) MSQCSpecial = 2;
                MSQCSpecial << (2)
                # (Line 301) }
                # (Line 302) }
            EUDEndIf()
            # (Line 306) if(MSQCSpecialBuffer[CP] == 200){
        EUDEndIf()
        if EUDIf()(MSQCSpecialBuffer[CP] == 200):
            # (Line 307) const orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength;
            orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength
            # (Line 308) ConnectStatus[CP] = 0;
            _ARRW(ConnectStatus, CP) << (0)
            # (Line 309) MSQCSpecialBuffer[CP] = 0;
            _ARRW(MSQCSpecialBuffer, CP) << (0)
            # (Line 310) SCACommand[CP] = 0;
            _ARRW(SCACommand, CP) << (0)
            # (Line 311) SCALastMessage[CP] = 2;
            _ARRW(SCALastMessage, CP) << (2)
            # (Line 312) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 313) PlayWAV("sound\\Bullet\\tscFir00.wav");
                # (Line 314) f_eprintln("\x03SCArchive\x04와 \x07연결\x04이 \x08끊어졌습니다.");
                DoActions(PlayWAV("sound\\Bullet\\tscFir00.wav"))
                f_eprintln("\x03SCArchive\x04와 \x07연결\x04이 \x08끊어졌습니다.")
                # (Line 315) }
                # (Line 317) if (Memory(0x57F1B0,Exactly,CP)){
            EUDEndIf()
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 318) MSQCSpecial = 0;
                MSQCSpecial << (0)
                # (Line 319) wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0);
                f_wwrite_epd(EPD(scf.ws) + scf.EntryPointLength, 0, 0)
                # (Line 320) LastPing = 0;
                LastPing << (0)
                # (Line 321) bwrite_epd(orderAddrEPD, 2, 0);
                f_bwrite_epd(orderAddrEPD, 2, 0)
                # (Line 322) bwrite_epd(orderAddrEPD, 3, 0);
                f_bwrite_epd(orderAddrEPD, 3, 0)
                # (Line 323) MSQCCondiction = 0;
                MSQCCondiction << (0)
                # (Line 324) }
                # (Line 325) }
            EUDEndIf()
            # (Line 330) switch(SCACommand[CP]) {
        EUDEndIf()
        EUDSwitch(SCACommand[CP])
        # (Line 331) case 1:
        _t14 = EUDSwitchCase()
        # (Line 332) case 2:
        if _t14(1):
            pass
        _t15 = EUDSwitchCase()
        # (Line 333) case 3:
        if _t15(2):
            pass
        _t16 = EUDSwitchCase()
        # (Line 334) const orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength;
        if _t16(3):
            orderAddrEPD = EPD(scf.ws) + scf.EntryPointLength
            # (Line 335) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 337) bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP]);
                f_bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP])
                # (Line 339) bwrite_epd(orderAddrEPD, 2, SCACommand[CP]);
                f_bwrite_epd(orderAddrEPD, 2, SCACommand[CP])
                # (Line 340) }
                # (Line 345) const LauncherStatus = bread_epd(orderAddrEPD, 3);
            EUDEndIf()
            LauncherStatus = f_bread_epd(orderAddrEPD, 3)
            # (Line 346) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 347) if(rn[CP] == 1){
                if EUDIf()(rn[CP] == 1):
                    # (Line 348) f_eprintln("\x07불러오기 : \x03SCArchive\x04의 \x1F응답\x04을 \x07기다리는 중...");
                    f_eprintln("\x07불러오기 : \x03SCArchive\x04의 \x1F응답\x04을 \x07기다리는 중...")
                    # (Line 349) }else if(CheckIntegrityFlag[CP] == 0){
                if EUDElseIf()(CheckIntegrityFlag[CP] == 0):
                    # (Line 350) f_eprintln("\x07불러오기 : \x03데이터 불러오는 중 ... \x1FPage : ", rn[CP]);
                    f_eprintln("\x07불러오기 : \x03데이터 불러오는 중 ... \x1FPage : ", rn[CP])
                    # (Line 351) }else if(CheckIntegrityFlag[CP] == 1){
                if EUDElseIf()(CheckIntegrityFlag[CP] == 1):
                    # (Line 352) f_eprintln("\x07불러오기 : \x03전달 오류를 판단하는 중 ... ");
                    f_eprintln("\x07불러오기 : \x03전달 오류를 판단하는 중 ... ")
                    # (Line 353) }
                    # (Line 354) }
                EUDEndIf()
                # (Line 357) if(CheckIntegrityFlag[CP] == 0){
            EUDEndIf()
            if EUDIf()(CheckIntegrityFlag[CP] == 0):
                # (Line 358) if (Memory(0x57F1B0,Exactly,CP)){
                if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 359) MSQCCondiction = 1;
                    MSQCCondiction << (1)
                    # (Line 360) }
                    # (Line 363) {const RecevieValue = ReceiveValue(MSQCBuffer[CP]);
                EUDEndIf()
                RecevieValue = ReceiveValue(MSQCBuffer[CP])
                # (Line 365) if(ack[CP] == (rn[CP] % ackMax + 1)){
                if EUDIf()(ack[CP] == (rn[CP] % ackMax + 1)):
                    # (Line 367) const rseq = rn[CP] - 1;
                    rseq = rn[CP] - 1
                    # (Line 368) wwrite_epd(LoadAddrEPD[CP] + rseq / 2, (rseq % 2) * 2, RecevieValue);
                    f_wwrite_epd(LoadAddrEPD[CP] + rseq // 2, (rseq % 2) * 2, RecevieValue)
                    # (Line 369) rn[CP] += 1;
                    _ARRW(rn, CP).__iadd__(1)
                    # (Line 370) }else if(ack[CP] == 0 && RecevieValue == 0xFFFF){
                if EUDElseIf()(EUDSCAnd()(ack[CP] == 0)(RecevieValue == 0xFFFF)()):
                    # (Line 371) MaxBuffer[CP] = rn[CP] - 1;
                    _ARRW(MaxBuffer, CP) << (rn[CP] - 1)
                    # (Line 372) }else{
                if EUDElse()():
                    # (Line 373) const CurrentTimeer = (TimeOut - CurrentTime);
                    CurrentTimeer = (TimeOut - CurrentTime)
                    # (Line 374) if (CurrentTimeer > 500){
                    if EUDIf()(CurrentTimeer <= 500, neg=True):
                        # (Line 375) TimeOut = CurrentTime;
                        TimeOut << (CurrentTime)
                        # (Line 376) index = rn[CP];
                        index << (rn[CP])
                        # (Line 377) }
                        # (Line 378) }}
                    EUDEndIf()
                EUDEndIf()
                # (Line 382) if(LauncherStatus == 1){
                if EUDIf()(LauncherStatus == 1):
                    # (Line 383) const rseq = index - 1;
                    rseq = index - 1
                    # (Line 384) const CheckZero = dwread_epd(BaseAddrEPD[CP] + rseq / 2);
                    CheckZero = f_dwread_epd(BaseAddrEPD[CP] + rseq // 2)
                    # (Line 386) if (CheckZero == 0){
                    if EUDIf()(CheckZero == 0):
                        # (Line 388) if (Memory(0x57F1B0,Exactly,CP)){
                        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 389) MSQCValue = DisConnectCode % MapDim + (DisConnectCode / MapDim) * 0x10000;
                            MSQCValue << (DisConnectCode % MapDim + (DisConnectCode // MapDim) * 0x10000)
                            # (Line 390) }
                            # (Line 391) }else{
                        EUDEndIf()
                    if EUDElse()():
                        # (Line 392) SendValue(index);
                        SendValue(index)
                        # (Line 393) if (FrameTick > 70){
                        if EUDIf()(FrameTick <= 70, neg=True):
                            # (Line 394) LastTick = CurrentTime;
                            LastTick << (CurrentTime)
                            # (Line 395) index += 1;
                            index.__iadd__(1)
                            # (Line 396) }
                            # (Line 397) }
                        EUDEndIf()
                        # (Line 398) }
                    EUDEndIf()
                    # (Line 399) }
                EUDEndIf()
                # (Line 404) {if (rn[CP] > MaxBuffer[CP]){
            EUDEndIf()
            if EUDIf()(rn[CP] <= MaxBuffer[CP], neg=True):
                # (Line 405) const rseq = MaxBuffer[CP];
                rseq = MaxBuffer[CP]
                # (Line 406) dwwrite_epd(LoadAddrEPD[CP] + rseq / 2, 0);
                f_dwwrite_epd(LoadAddrEPD[CP] + rseq // 2, 0)
                # (Line 409) switch(CheckIntegrityFlag[CP]){
                EUDSwitch(CheckIntegrityFlag[CP])
                # (Line 410) case 0:
                _t32 = EUDSwitchCase()
                # (Line 411) if (Memory(0x57F1B0,Exactly,CP)){
                if _t32(0):
                    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                        # (Line 412) MSQCCondiction = 0;
                        MSQCCondiction << (0)
                        # (Line 413) }
                        # (Line 414) CheckIntegrity();
                    EUDEndIf()
                    CheckIntegrity()
                    # (Line 415) CheckIntegrityFlag[CP] = 1;
                    _ARRW(CheckIntegrityFlag, CP) << (1)
                    # (Line 416) break;
                    EUDBreak()
                    # (Line 417) case 1:
                _t34 = EUDSwitchCase()
                # (Line 418) CheckIntegrity();
                if _t34(1):
                    CheckIntegrity()
                    # (Line 420) if(MSQCSpecialBuffer[CP] == 300){
                    if EUDIf()(MSQCSpecialBuffer[CP] == 300):
                        # (Line 422) CheckIntegrityFlag[CP] = 2;
                        _ARRW(CheckIntegrityFlag, CP) << (2)
                        # (Line 423) MSQCSpecialBuffer[CP] = 0;
                        _ARRW(MSQCSpecialBuffer, CP) << (0)
                        # (Line 424) if (Memory(0x57F1B0,Exactly,CP)){
                        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 425) MSQCSpecial = 0;
                            MSQCSpecial << (0)
                            # (Line 426) }
                            # (Line 427) }
                        EUDEndIf()
                        # (Line 428) if(MSQCSpecialBuffer[CP] == 400){
                    EUDEndIf()
                    if EUDIf()(MSQCSpecialBuffer[CP] == 400):
                        # (Line 429) CheckIntegrityFlag[CP] = 0;
                        _ARRW(CheckIntegrityFlag, CP) << (0)
                        # (Line 430) MaxBuffer[CP] = scf.SpaceLength / 2;
                        _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
                        # (Line 431) rn[CP] = 1;
                        _ARRW(rn, CP) << (1)
                        # (Line 432) ack[CP] = 0;
                        _ARRW(ack, CP) << (0)
                        # (Line 433) if (Memory(0x57F1B0,Exactly,CP)){
                        if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                            # (Line 434) MSQCSpecial = 0;
                            MSQCSpecial << (0)
                            # (Line 435) index = 1;
                            index << (1)
                            # (Line 436) }
                            # (Line 437) }
                        EUDEndIf()
                        # (Line 438) break;
                    EUDEndIf()
                    EUDBreak()
                    # (Line 439) case 2:
                _t39 = EUDSwitchCase()
                # (Line 440) if (Memory(0x57F1B0,Exactly,CP)){
                if _t39(2):
                    if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                        # (Line 441) bwrite_epd(orderAddrEPD, 2, 0);
                        f_bwrite_epd(orderAddrEPD, 2, 0)
                        # (Line 442) bwrite_epd(orderAddrEPD, 3, 0);
                        f_bwrite_epd(orderAddrEPD, 3, 0)
                        # (Line 443) MSQCValue = 0;
                        MSQCValue << (0)
                        # (Line 444) MSQCCondiction = 0;
                        MSQCCondiction << (0)
                        # (Line 445) }
                        # (Line 446) LoadDataRead(rn[CP] - 1);
                    EUDEndIf()
                    LoadDataRead(rn[CP] - 1)
                    # (Line 447) SCACommand[CP] = 0;
                    _ARRW(SCACommand, CP) << (0)
                    # (Line 449) SCALastMessage[CP] = 4;
                    _ARRW(SCALastMessage, CP) << (4)
                    # (Line 450) if (SCAUseUserMessage == 1){
                    if EUDIf()(SCAUseUserMessage == 1):
                        # (Line 451) PlayWAV("sound\\Misc\\TDrTra01.wav");
                        # (Line 452) f_eprintln("\x07성공적으로 \x03데이터\x04를 불러왔습니다.");
                        DoActions(PlayWAV("sound\\Misc\\TDrTra01.wav"))
                        f_eprintln("\x07성공적으로 \x03데이터\x04를 불러왔습니다.")
                        # (Line 453) }
                        # (Line 454) break;
                    EUDEndIf()
                    EUDBreak()
                    # (Line 455) }
                # (Line 456) }}
                EUDEndSwitch()
            EUDEndIf()
            # (Line 457) break;
            EUDBreak()
            # (Line 458) case 4:
        _t42 = EUDSwitchCase()
        # (Line 459) if (Memory(0x57F1B0,Exactly,CP)){
        if _t42(4):
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 461) bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP]);
                f_bwrite_epd(orderAddrEPD + 1, 0, DataSlot[CP])
                # (Line 464) bwrite_epd(orderAddrEPD, 2, SCACommand[CP]);
                f_bwrite_epd(orderAddrEPD, 2, SCACommand[CP])
                # (Line 466) }
                # (Line 471) const LauncherStatus2 = bread_epd(orderAddrEPD, 3);
            EUDEndIf()
            LauncherStatus2 = f_bread_epd(orderAddrEPD, 3)
            # (Line 472) if(LauncherStatus2 == 1){
            if EUDIf()(LauncherStatus2 == 1):
                # (Line 474) if (Memory(0x57F1B0,Exactly,CP)){
                if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 475) MSQCValue = 100;
                    MSQCValue << (100)
                    # (Line 476) MSQCCondiction = 1;
                    MSQCCondiction << (1)
                    # (Line 477) }
                    # (Line 478) }
                EUDEndIf()
                # (Line 479) if(MSQCBuffer[CP] == 100){
            EUDEndIf()
            if EUDIf()(MSQCBuffer[CP] == 100):
                # (Line 480) if (Memory(0x57F1B0,Exactly,CP)){
                if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                    # (Line 481) bwrite_epd(orderAddrEPD, 2, 0);
                    f_bwrite_epd(orderAddrEPD, 2, 0)
                    # (Line 482) bwrite_epd(orderAddrEPD, 3, 0);
                    f_bwrite_epd(orderAddrEPD, 3, 0)
                    # (Line 483) MSQCValue = 0;
                    MSQCValue << (0)
                    # (Line 484) MSQCCondiction = 0;
                    MSQCCondiction << (0)
                    # (Line 485) }
                    # (Line 486) SCACommand[CP] = 0;
                EUDEndIf()
                _ARRW(SCACommand, CP) << (0)
                # (Line 488) SCALastMessage[CP] = 6;
                _ARRW(SCALastMessage, CP) << (6)
                # (Line 489) if (SCAUseUserMessage == 1){
                if EUDIf()(SCAUseUserMessage == 1):
                    # (Line 490) PlayWAV("sound\\Misc\\TDrTra01.wav");
                    # (Line 491) f_eprintln("\x07성공적으로 \x03데이터\x04를 저장했습니다.");
                    DoActions(PlayWAV("sound\\Misc\\TDrTra01.wav"))
                    f_eprintln("\x07성공적으로 \x03데이터\x04를 저장했습니다.")
                    # (Line 492) }
                    # (Line 493) }
                EUDEndIf()
                # (Line 494) break;
            EUDEndIf()
            EUDBreak()
            # (Line 495) }
        # (Line 496) }else{
        EUDEndSwitch()
    if EUDElse()():
        # (Line 497) if(MSQCSpecialBuffer[CP] == 100){
        if EUDIf()(MSQCSpecialBuffer[CP] == 100):
            # (Line 498) ConnectStatus[CP] = 1;
            _ARRW(ConnectStatus, CP) << (1)
            # (Line 499) MSQCSpecialBuffer[CP] = 0;
            _ARRW(MSQCSpecialBuffer, CP) << (0)
            # (Line 500) SCALastMessage[CP] = 1;
            _ARRW(SCALastMessage, CP) << (1)
            # (Line 501) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 502) PlayWAV("sound\\Misc\\ZRescue.wav");
                # (Line 503) f_eprintln("\x03SCArchive\x04와 \x07연결\x04되었습니다.");
                DoActions(PlayWAV("sound\\Misc\\ZRescue.wav"))
                f_eprintln("\x03SCArchive\x04와 \x07연결\x04되었습니다.")
                # (Line 504) }
                # (Line 505) if (Memory(0x57F1B0,Exactly,CP)){
            EUDEndIf()
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 506) MSQCSpecial = 0;
                MSQCSpecial << (0)
                # (Line 507) }
                # (Line 508) }
            EUDEndIf()
            # (Line 509) }
        EUDEndIf()
        # (Line 514) }
    EUDEndIf()
    # (Line 516) function Exec(){

@EUDFunc
def Exec():
    # (Line 517) EUDPlayerLoop()();
    EUDPlayerLoop()()
    # (Line 518) PlayerExec();
    PlayerExec()
    # (Line 519) EUDEndPlayerLoop();
    EUDEndPlayerLoop()
    # (Line 520) }
    # (Line 523) function DataLoad(Slot){

@EUDFunc
def DataLoad(Slot):
    # (Line 524) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 526) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 527) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 528) DataSlot[CP] = Slot;
            _ARRW(DataSlot, CP) << (Slot)
            # (Line 529) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 530) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 533) LastTick = dwread_epd(EPD(0x51CE8C));
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 535) SCALastMessage[CP] = 3;
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 536) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 537) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 538) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 539) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 540) MaxBuffer[CP] = scf.SpaceLength / 2;
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 541) rn[CP] = 1;
            _ARRW(rn, CP) << (1)
            # (Line 542) ack[CP] = 0;
            _ARRW(ack, CP) << (0)
            # (Line 543) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 544) MSQCValue = 0;
                MSQCValue << (0)
                # (Line 545) index = 1;
                index << (1)
                # (Line 546) }
                # (Line 547) SCACommand[CP] = 1;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (1)
            # (Line 548) MSQCBuffer[CP] = 0;
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 549) }else{
        if EUDElse()():
            # (Line 550) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 551) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 552) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 553) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 554) }
                # (Line 555) }
            EUDEndIf()
            # (Line 556) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 557) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 558) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 559) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 560) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 561) }
            # (Line 562) }
        EUDEndIf()
        # (Line 563) }
    EUDEndIf()
    # (Line 566) function DataSave(Slot){

@EUDFunc
def DataSave(Slot):
    # (Line 567) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 569) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 570) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 571) DataSlot[CP] = Slot;
            _ARRW(DataSlot, CP) << (Slot)
            # (Line 572) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 574) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 575) SaveDataWrite();
                SaveDataWrite()
                # (Line 576) }
                # (Line 578) MSQCBuffer[CP] = 0;
            EUDEndIf()
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 579) SCALastMessage[CP] = 5;
            _ARRW(SCALastMessage, CP) << (5)
            # (Line 580) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 581) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 582) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 584) SCACommand[CP] = 4;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (4)
            # (Line 585) }else{
        if EUDElse()():
            # (Line 586) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 587) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 588) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 589) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 590) }
                # (Line 591) }
            EUDEndIf()
            # (Line 592) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 593) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 594) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 595) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 596) f_eprintln("\x08데이터를 저장하기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 저장하기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 597) }
            # (Line 598) }
        EUDEndIf()
        # (Line 599) }
    EUDEndIf()
    # (Line 603) function GetDate(){

@EUDFunc
def GetDate():
    # (Line 604) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 605) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 606) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 607) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 608) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 611) LastTick = dwread_epd(EPD(0x51CE8C));
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 613) SCALastMessage[CP] = 3;
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 614) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 615) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 616) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 617) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 618) MaxBuffer[CP] = scf.SpaceLength / 2;
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 619) rn[CP] = 1;
            _ARRW(rn, CP) << (1)
            # (Line 620) ack[CP] = 0;
            _ARRW(ack, CP) << (0)
            # (Line 621) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 622) MSQCValue = 0;
                MSQCValue << (0)
                # (Line 623) index = 1;
                index << (1)
                # (Line 624) }
                # (Line 625) SCACommand[CP] = 2;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (2)
            # (Line 626) MSQCBuffer[CP] = 0;
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 627) }else{
        if EUDElse()():
            # (Line 628) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 629) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 630) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 631) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 632) }
                # (Line 633) }
            EUDEndIf()
            # (Line 634) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 635) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 636) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 637) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 638) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 639) }
            # (Line 640) }
        EUDEndIf()
        # (Line 641) }
    EUDEndIf()
    # (Line 644) function LoadGlobalData(){

@EUDFunc
def LoadGlobalData():
    # (Line 645) const CP = getcurpl();
    CP = f_getcurpl()
    # (Line 646) if (ConnectStatus[CP] == 1){
    if EUDIf()(ConnectStatus[CP] == 1):
        # (Line 647) if (SCACommand[CP] == 0){
        if EUDIf()(SCACommand[CP] == 0):
            # (Line 648) BaseAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4;
            _ARRW(BaseAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4)
            # (Line 649) LoadAddrEPD[CP] = EPD(scf.ws) + scf.EntryPointLength + CommandLength / 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) / 4;
            _ARRW(LoadAddrEPD, CP) << (EPD(scf.ws) + scf.EntryPointLength + CommandLength // 4 + ((scf.SpaceLength + CommandLength) * (CP + 1)) // 4)
            # (Line 652) LastTick = dwread_epd(EPD(0x51CE8C));
            LastTick << (f_dwread_epd(EPD(0x51CE8C)))
            # (Line 654) SCALastMessage[CP] = 3;
            _ARRW(SCALastMessage, CP) << (3)
            # (Line 655) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 656) PlayWAV("sound\\glue\\swishin.wav");
                # (Line 657) }
                DoActions(PlayWAV("sound\\glue\\swishin.wav"))
                # (Line 658) CheckIntegrityFlag[CP] = 0;
            EUDEndIf()
            _ARRW(CheckIntegrityFlag, CP) << (0)
            # (Line 659) MaxBuffer[CP] = scf.SpaceLength / 2;
            _ARRW(MaxBuffer, CP) << (scf.SpaceLength // 2)
            # (Line 660) rn[CP] = 1;
            _ARRW(rn, CP) << (1)
            # (Line 661) ack[CP] = 0;
            _ARRW(ack, CP) << (0)
            # (Line 662) if (Memory(0x57F1B0,Exactly,CP)){
            if EUDIf()(Memory(0x57F1B0, Exactly, CP)):
                # (Line 663) MSQCValue = 0;
                MSQCValue << (0)
                # (Line 664) index = 1;
                index << (1)
                # (Line 665) }
                # (Line 666) SCACommand[CP] = 3;
            EUDEndIf()
            _ARRW(SCACommand, CP) << (3)
            # (Line 667) MSQCBuffer[CP] = 0;
            _ARRW(MSQCBuffer, CP) << (0)
            # (Line 668) }else{
        if EUDElse()():
            # (Line 669) SCALastMessage[CP] = 8;
            _ARRW(SCALastMessage, CP) << (8)
            # (Line 670) if (SCAUseUserMessage == 1){
            if EUDIf()(SCAUseUserMessage == 1):
                # (Line 671) PlayWAV("sound\\Misc\\PError.WAV");
                # (Line 672) f_eprintln("\x08현재 다른 작업중입니다.");
                DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
                f_eprintln("\x08현재 다른 작업중입니다.")
                # (Line 673) }
                # (Line 674) }
            EUDEndIf()
            # (Line 675) }else{
        EUDEndIf()
    if EUDElse()():
        # (Line 676) SCALastMessage[CP] = 7;
        _ARRW(SCALastMessage, CP) << (7)
        # (Line 677) if (SCAUseUserMessage == 1){
        if EUDIf()(SCAUseUserMessage == 1):
            # (Line 678) PlayWAV("sound\\Misc\\PError.WAV");
            # (Line 679) f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.");
            DoActions(PlayWAV("sound\\Misc\\PError.WAV"))
            f_eprintln("\x08데이터를 불러오기 위해선 SCArchive와 연결되어야 합니다.")
            # (Line 680) }
            # (Line 681) }
        EUDEndIf()
        # (Line 682) }
    EUDEndIf()
