import py_math;

const step		= PVariable();			// SkillStep
const count 		= PVariable();			// SkillCount	
const loop 		= PVariable();			// SkillLoop
const delay		= PVariable();			// wait(value);
const wait		= PVariable();			// SkillWait
	
const location 	= PVariable();			// 로케이션 번호
const heroID 	= PVariable();			// 영웅 유닛 번호

const UltimateA	= PVariable();			// 궁극기 1번 소모량
const UltimateB	= PVariable();			// 궁극기 2번 소모량
const UltimateC	= PVariable();			// 궁극기 3번 소모량

const UniqueA	= PVariable();			// 유니크 1번 쿨타임

const distance	= PVariable();			// 거리 관련 변수
const SinAngle 	= PVariable();			// Sin 변수
const CosAngle 	= PVariable();			// Cos 변수

const CosTableArray = EUDArray(py_eval("[int(round(100*math.cos(math.radians(t)))) for t in range(361)]"));
const SinTableArray 	= EUDArray(py_eval("[int(round(100*math.sin(math.radians(t)))) for t in range(361)]"));

const Rusaruka_Voice 	= PVariable();
const Yuuna_Voice 		= PVariable();

function Voice_Routine(cp, num)
{
	switch(heroID[cp])
	{
	case 1:
		Rusaruka_Voice[0] = num;
		Rusaruka_Voice[1] = num;
		Rusaruka_Voice[2] = num;
		Rusaruka_Voice[3] = num;
		Rusaruka_Voice[4] = num;
		Rusaruka_Voice[5] = num;
		break;
	case 22:
		Yuuna_Voice[0] = num;
		Yuuna_Voice[1] = num;
		Yuuna_Voice[2] = num;
		Yuuna_Voice[3] = num;
		Yuuna_Voice[4] = num;
		Yuuna_Voice[5] = num;
		break;
	}
}

function Table_Sin(cp, degree, distance);
function Table_Cos(cp, degree, distance);

function MoveLoc(Unit : TrgUnit, location : TrgLocation, cp : TrgPlayer, x, y)
{
	MoveLocation(location, Unit, cp, "Anywhere");
	addloc(location - 1, x, y);
}

function SkillUnit(count, Unit : TrgUnit, location : TrgLocation, cp : TrgPlayer)
{
	CreateUnit(count, Unit, "[Skill]Unit_Wait_1", cp);
	SetInvincibility(Enable, Unit, cp, "[Skill]Unit_Wait_ALL");
	MoveUnit(count, Unit, cp, "[Skill]Unit_Wait_ALL", location);
}

function SkillWait(cp, count)
{
	delay[cp] = count/83 + 1;
}

function SkillEnd(cp)
{
	wait[cp] = 12;
}

function SquareShape(heroID : TrgUnit, count, Unit : TrgUnit, location : TrgLocation, cp : TrgPlayer, x, y)
{
	MoveLoc(heroID, location, cp, x, y);
	SkillUnit(count, Unit, location, cp);
	MoveLoc(heroID, location, cp, -y, x);
	SkillUnit(count, Unit, location, cp);
	MoveLoc(heroID, location, cp, -x, -y);
	SkillUnit(count, Unit, location, cp);
	MoveLoc(heroID, location, cp, y, -x);
	SkillUnit(count, Unit, location, cp);
}

function NxNSquareShape(heroID : TrgUnit, count, Unit : TrgUnit, location : TrgLocation, cp : TrgPlayer, n, interval)
{
	var i = 0;
	var destX, destY; 
	var distance = interval / 2;
	var size = n * n;

	for (; i < size / 4; i++)
	{
		if (n == 1)
		{
			MoveLoc(heroID, location, cp, 0, 0);
			SkillUnit(count, Unit, location, cp);
		}
		else if (n % 2 == 0)
		{
			destX = i % (n / 2) + 1;
			destY = i / (n / 2) + 1;
			if (destX == 1)
			{
				SquareShape(heroID, count, Unit, location, cp, distance, destY * interval - distance);
			}
			else if (destY == 1)
			{
				SquareShape(heroID, count, Unit, location, cp, destX * interval - distance, distance);
			}
			else
			{
				SquareShape(heroID, count, Unit, location, cp, destX * interval - distance, destY * interval - distance);
			}
		}
		else if (n % 2 == 1)
		{
			destX = i % (n / 2);
			destY = i / (n / 2);
	
			if (i == 0)
			{
				MoveLoc(heroID, location, cp, 0, 0);
				SkillUnit(count, Unit, location, cp);
			}
			else if (destY == 0)
			{
				SquareShape(heroID, count, Unit, location, cp, destX * interval, 0);
			}
			else
			{
				SquareShape(heroID, count, Unit, location, cp, destX * interval + interval, destY * interval);
			}
			
			if (i == size / 4 - 1)
			{
				SquareShape(heroID, count, Unit, location, cp, (n / 2) * interval, 0);
			}
		}
	}
}

function lineShape(heroID : TrgUnit, count, Unit : TrgUnit, location : TrgLocation, cp : TrgPlayer, degree, n, interval, distanceX, distanceY)
{
	var i = 0;
	var distance = interval / 2;
	
	Table_Sin(cp, degree, interval);
	Table_Cos(cp, degree, interval);
	
	var gradientX = CosAngle[cp] / 2;
	var gradientY = SinAngle[cp] / 2;
	
	for (; i < n / 2 + 1; i++)
	{
		if (n % 2 == 0 && i != n / 2)
		{
			MoveLoc(heroID, location, cp, -CosAngle[cp] * i - gradientX + (distanceX * i), SinAngle[cp] * i + gradientY + (distanceY * i));
			SkillUnit(count, Unit, location, cp);
			MoveLoc(heroID, location, cp, CosAngle[cp] * i + gradientX + (distanceX * i), -SinAngle[cp] * i - gradientY - (distanceY * i));
			SkillUnit(count, Unit, location, cp);
		}
		else if (n % 2 == 1)
		{
			if (i == 0)
			{
				MoveLoc(heroID, location, cp, distanceX, distanceY);
				SkillUnit(count, Unit, location, cp);
			}
			else
			{
				MoveLoc(heroID, location, cp, -CosAngle[cp] * i - (distanceX * i), SinAngle[cp] * i + (distanceY * i));
				SkillUnit(count, Unit, location, cp);
				MoveLoc(heroID, location, cp, CosAngle[cp] * i + (distanceX * i), -SinAngle[cp] * i - (distanceY * i));
				SkillUnit(count, Unit, location, cp);
			}
		}
	}
}


function LineShape(heroID : TrgUnit, count, Unit : TrgUnit, location : TrgLocation, cp : TrgPlayer, degree, n, interval, distance)
{
	var i = 0;

	Table_Sin(cp, degree + 90, distance);
	Table_Cos(cp, degree + 90, distance);
	var x_initial = CosAngle[cp];
	var y_initial = SinAngle[cp];
	
	if (n / 2 == 0)
	{
		Table_Sin(cp, degree, interval * (n / 2) - interval / 2);
		Table_Cos(cp, degree, interval * (n / 2) - interval / 2);
	}
	else
	{
		Table_Sin(cp, degree, interval * (n / 2));
		Table_Cos(cp, degree, interval * (n / 2));
	}
	
	x_initial = x_initial + CosAngle[cp];
	y_initial = y_initial + SinAngle[cp];
	
	Table_Sin(cp, degree, interval);
	Table_Cos(cp, degree, interval);
	
	for (; i < n; i++)
	{
		MoveLoc(heroID, location, cp, x_initial - i * CosAngle[cp], y_initial - i * SinAngle[cp]);
		SkillUnit(count, Unit, location, cp);
	}
	
}

function Table_Sin(cp, degree, distance)
{
	degree = degree % 360;
	SinAngle[cp] = SinTableArray[degree];
	
	if (SinAngle[cp] > 2147483648)
	{
		SinAngle[cp] = -SinAngle[cp];
		SinAngle[cp] = (SinAngle[cp] * distance) / 100;
		SinAngle[cp] = -SinAngle[cp];
	}
	else
	{
		SinAngle[cp] = (SinAngle[cp] * distance) / 100;
	}
}

function Table_Cos(cp, degree, distance)
{
	degree = degree % 360;
	CosAngle[cp] = CosTableArray[degree];
	
	if (CosAngle[cp] > 2147483648)
	{
		CosAngle[cp] = -CosAngle[cp];
		CosAngle[cp] = (CosAngle[cp] * distance) / 100;
		CosAngle[cp] = -CosAngle[cp];
	}
	else
	{
		CosAngle[cp] = (CosAngle[cp] * distance) / 100;
	}
}
