import customText as tct;
import Variable as v;

var txtPtr, btnPtr, btnPos, oldCP;
const trgk = $T('Artanis & safhfh');

function BuildingText(cp) 
{
	if (v.Unit_ID[cp] != 0 && v.Unit_ID[cp] != v.BuildingText[cp])
	{ 
		v.BuildingText[cp] = v.Unit_ID[cp]; 
	}
	
	switch(v.BuildingText[cp]) 
	{
		case 81:
			v.Unit_HP[cp] = dwread_epd(v.Unit_NowIndex[cp] + 0x008 / 4) / 256;
			txtPtr = dwread_epd(EPD(0x640B58));
			tct.print("\x13\x19[ \x1FP\x04olarlicht \x19]\n\x13\x04\x1955초 \x04마다 Hoffnung [용병] 스텍이 5 추가로 증가합니다.\n\n\x13\x04남은 체력 : ", v.Unit_HP[cp], " / 30000");
			SetMemory(0x640B58, SetTo, txtPtr);
			break;
		case 79:
			v.Unit_HP[cp] = dwread_epd(v.Unit_NowIndex[cp] + 0x008 / 4) / 256;
			txtPtr = dwread_epd(EPD(0x640B58));
			tct.print("\x13\x19[ \x1BS\x04chnee \x19]\n\x13\x04제거시 \x1B신전 \x04의 무적이 해제됩니다.\n\n\x13\x04남은 체력 : ", v.Unit_HP[cp], " / 110000");
			SetMemory(0x640B58, SetTo, txtPtr);
			break;
		case 168:
			v.Unit_HP[cp] = dwread_epd(v.Unit_NowIndex[cp] + 0x008 / 4) / 256;
			txtPtr = dwread_epd(EPD(0x640B58));
			tct.print("\x13\x19[ \x1BB\x04runnen \x19]\n\x13\x04모두 제거시 \x1BS\x04chnee [수호자] 의 무적이 해제됩니다.\n\n\x13\x04남은 체력 : ", v.Unit_HP[cp], " / 50000");
			SetMemory(0x640B58, SetTo, txtPtr);
			break;
		case 175:
			v.Unit_HP[cp] = dwread_epd(v.Unit_NowIndex[cp] + 0x008 / 4) / 256;
			txtPtr = dwread_epd(EPD(0x640B58));
			tct.print("\x13\x19[ \x1BM\x04ond \x19]\n\n\x13\x04남은 체력 : ", v.Unit_HP[cp], " / 200000");
			SetMemory(0x640B58, SetTo, txtPtr);
			break;
		case 189:
			txtPtr = dwread_epd(EPD(0x640B58));
			tct.print("\x13\x19[ \x1BP\x04ortal \x19]\n\n\x13\x04상점에 들어가거나 원하는 라인으로 이동 해주는 건물입니다.");
			SetMemory(0x640B58, SetTo, txtPtr);
			break;
		case 200:
			v.Unit_HP[cp] = dwread_epd(v.Unit_NowIndex[cp] + 0x008 / 4) / 256;
			txtPtr = dwread_epd(EPD(0x640B58));
			tct.print("\x13\x19[ \x1BW\x04ald \x19]\n\x13\x04제거시 \x1B방어건물 \x04의 무적이 해제됩니다.\n\n\x13\x04남은 체력 : ", v.Unit_HP[cp], " / 70000");
			SetMemory(0x640B58, SetTo, txtPtr);
			break;
	}
	
}