## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import System.Variable as v;
from System import Variable as v
# (Line 2) import System.Announce as a;
from System import Announce as a
# (Line 3) import System.Text as t;
from System import Text as t
# (Line 4) import Princess.Variable as pv;
from Princess import Variable as pv
# (Line 5) import Fairy.Variable as fv;
from Fairy import Variable as fv
# (Line 6) import Angel.Variable as av;
from Angel import Variable as av
# (Line 8) import Title.Variable as tv;
from Title import Variable as tv
# (Line 9) import Title.Effect as te;
from Title import Effect as te
# (Line 11) function Init();
# (Line 12) function FixedUpdate();
# (Line 13) function Set_Round();
# (Line 14) function Set_RoundHP();
# (Line 15) function Start_Round_Text(cp);
# (Line 16) function End_Round_Text(cp);
# (Line 19) var NR;
NR = EUDVariable()
# (Line 20) const EDSound = PVariable();
EDSound = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 21) const STSound = PVariable();
STSound = _CGFW(lambda: [PVariable()], 1)[0]
# (Line 23) const s = StringBuffer();
s = _CGFW(lambda: [StringBuffer()], 1)[0]
# (Line 25) function Init()
# (Line 26) {
@EUDFunc
def Init():
    # (Line 28) }
    # (Line 30) function FixedUpdate()
    pass

# (Line 31) {
@EUDFunc
def FixedUpdate():
    # (Line 32) Set_RoundHP();
    Set_RoundHP()
    # (Line 33) }
    # (Line 35) function PlayerUpdate(cp)

# (Line 36) {
@EUDFunc
def PlayerUpdate(cp):
    # (Line 37) Start_Round_Text(cp);
    Start_Round_Text(cp)
    # (Line 38) End_Round_Text(cp);
    End_Round_Text(cp)
    # (Line 39) }
    # (Line 41) function Set_RoundHP()

# (Line 42) {
@EUDFunc
def Set_RoundHP():
    # (Line 43) if(NR != dwread_epd(185 * 12 + 6))
    if EUDIf()(NR == f_dwread_epd(185 * 12 + 6), neg=True):
        # (Line 44) {
        # (Line 45) NR = dwread_epd(185 * 12 + 6);
        NR << (f_dwread_epd(185 * 12 + 6))
        # (Line 46) te.Add_Dear();
        te.Add_Dear()
        # (Line 48) if (v.Music_Number[NR] != 999 && NR < 56)
        if EUDIf()(EUDSCAnd()(v.Music_Number[NR] == 999, neg=True)(NR >= 56, neg=True)()):
            # (Line 49) {
            # (Line 50) SetDeaths(AllPlayers, SetTo, v.Music_Number[NR], 35);
            # (Line 51) SetDeaths(AllPlayers, SetTo, NR, 213);
            DoActions(SetDeaths(AllPlayers, SetTo, v.Music_Number[NR], 35))
            # (Line 52) }
            DoActions(SetDeaths(AllPlayers, SetTo, NR, 213))
            # (Line 54) var roundCheck = NR % 10;
        EUDEndIf()
        roundCheck = EUDVariable()
        roundCheck << (NR % 10)
        # (Line 55) var roundHp;
        roundHp = EUDVariable()
        # (Line 57) var mission = dwrand()%3 + 1;
        mission = EUDVariable()
        mission << (f_dwrand() % 3 + 1)
        # (Line 58) bwrite(0x65FD00 + 9344 + 135 * 1, mission);
        f_bwrite(0x65FD00 + 9344 + 135 * 1, mission)
        # (Line 59) bwrite(0x65FD00 + 14544 + 135 * 1, 29 + mission);
        f_bwrite(0x65FD00 + 14544 + 135 * 1, 29 + mission)
        # (Line 61) switch (roundCheck)
        EUDSwitch(roundCheck)
        # (Line 62) {
        # (Line 63) case 1:
        _t3 = EUDSwitchCase()
        # (Line 64) case 4:
        if _t3(1):
            pass
        _t4 = EUDSwitchCase()
        # (Line 65) case 7:
        if _t4(4):
            pass
        _t5 = EUDSwitchCase()
        # (Line 66) roundHp = v.Round_Hp[NR] * (100 - pv.Album_Level[7] * pv.Album_Multiply[7]);
        if _t5(7):
            roundHp << (v.Round_Hp[NR] * (100 - pv.Album_Level[7] * pv.Album_Multiply[7]))
            # (Line 67) if (Bring(P8, AtLeast, 1, tv.isTitle_Complete[13], "Title")) { dwwrite(0x65FD00 + 9808 + 93 * 4, (roundHp * 256) / 100); }
            if EUDIf()(Bring(P8, AtLeast, 1, tv.isTitle_Complete[13], "Title")):
                f_dwwrite(0x65FD00 + 9808 + 93 * 4, (roundHp * 256) // 100)
                # (Line 68) else { dwwrite(0x65FD00 + 9808 + 93 * 4, (roundHp * 9 * 256) / 1000); }
            if EUDElse()():
                f_dwwrite(0x65FD00 + 9808 + 93 * 4, (roundHp * 9 * 256) // 1000)
                # (Line 70) dwwrite(0x65FD00 + 9808 + 135 * 4, (roundHp * 30 * 256) / 100);
            EUDEndIf()
            f_dwwrite(0x65FD00 + 9808 + 135 * 4, (roundHp * 30 * 256) // 100)
            # (Line 71) SetDeaths(P8, SetTo, 0, 207);
            # (Line 72) break;
            DoActions(SetDeaths(P8, SetTo, 0, 207))
            EUDBreak()
            # (Line 73) case 2:
        _t7 = EUDSwitchCase()
        # (Line 74) case 5:
        if _t7(2):
            pass
        _t8 = EUDSwitchCase()
        # (Line 75) case 8:
        if _t8(5):
            pass
        _t9 = EUDSwitchCase()
        # (Line 76) roundHp = v.Round_Hp[NR] * (100 - fv.Album_Level[6] * fv.Album_Multiply[6]);
        if _t9(8):
            roundHp << (v.Round_Hp[NR] * (100 - fv.Album_Level[6] * fv.Album_Multiply[6]))
            # (Line 77) if (Bring(P8, AtLeast, 1, tv.isTitle_Complete[17], "Title")) { dwwrite(0x65FD00 + 9808 + 94 * 4, (roundHp * 256) / 100); }
            if EUDIf()(Bring(P8, AtLeast, 1, tv.isTitle_Complete[17], "Title")):
                f_dwwrite(0x65FD00 + 9808 + 94 * 4, (roundHp * 256) // 100)
                # (Line 78) else { dwwrite(0x65FD00 + 9808 + 94 * 4, (roundHp * 9 * 256) / 1000); }
            if EUDElse()():
                f_dwwrite(0x65FD00 + 9808 + 94 * 4, (roundHp * 9 * 256) // 1000)
                # (Line 80) dwwrite(0x65FD00 + 9808 + 135 * 4, (roundHp * 30 * 256) / 100);
            EUDEndIf()
            f_dwwrite(0x65FD00 + 9808 + 135 * 4, (roundHp * 30 * 256) // 100)
            # (Line 81) SetDeaths(P8, SetTo, 1, 207);
            # (Line 82) break;
            DoActions(SetDeaths(P8, SetTo, 1, 207))
            EUDBreak()
            # (Line 83) case 3:
        _t11 = EUDSwitchCase()
        # (Line 84) case 6:
        if _t11(3):
            pass
        _t12 = EUDSwitchCase()
        # (Line 85) case 9:
        if _t12(6):
            pass
        _t13 = EUDSwitchCase()
        # (Line 86) roundHp = v.Round_Hp[NR] * (100 - av.Album_Level[7] * av.Album_Multiply[7]);
        if _t13(9):
            roundHp << (v.Round_Hp[NR] * (100 - av.Album_Level[7] * av.Album_Multiply[7]))
            # (Line 87) if (Bring(P8, AtLeast, 1, tv.isTitle_Complete[21], "Title")) { dwwrite(0x65FD00 + 9808 + 95 * 4, (roundHp * 256) / 100); }
            if EUDIf()(Bring(P8, AtLeast, 1, tv.isTitle_Complete[21], "Title")):
                f_dwwrite(0x65FD00 + 9808 + 95 * 4, (roundHp * 256) // 100)
                # (Line 88) else { dwwrite(0x65FD00 + 9808 + 95 * 4, (roundHp * 9 * 256) / 1000); }
            if EUDElse()():
                f_dwwrite(0x65FD00 + 9808 + 95 * 4, (roundHp * 9 * 256) // 1000)
                # (Line 90) dwwrite(0x65FD00 + 9808 + 135 * 4, (roundHp * 30 * 256) / 100);
            EUDEndIf()
            f_dwwrite(0x65FD00 + 9808 + 135 * 4, (roundHp * 30 * 256) // 100)
            # (Line 91) SetDeaths(P8, SetTo, 2, 207);
            # (Line 92) break;
            DoActions(SetDeaths(P8, SetTo, 2, 207))
            EUDBreak()
            # (Line 93) case 0:
        _t15 = EUDSwitchCase()
        # (Line 94) dwwrite(0x65FD00 + 9808 + 96 * 4, v.Round_Hp[NR] * 256);
        if _t15(0):
            f_dwwrite(0x65FD00 + 9808 + 96 * 4, v.Round_Hp[NR] * 256)
            # (Line 95) SetDeaths(P8, SetTo, 3, 207);
            # (Line 97) if (NR == 10)
            DoActions(SetDeaths(P8, SetTo, 3, 207))
            if EUDIf()(NR == 10):
                # (Line 98) {
                # (Line 99) var boss = dwrand()%3 + 1;
                boss = EUDVariable()
                boss << (f_dwrand() % 3 + 1)
                # (Line 100) bwrite(0x65FD00 + 9344 + 133 * 1, boss);
                f_bwrite(0x65FD00 + 9344 + 133 * 1, boss)
                # (Line 101) bwrite(0x65FD00 + 14544 + 133 * 1, 29 + boss);
                f_bwrite(0x65FD00 + 14544 + 133 * 1, 29 + boss)
                # (Line 102) dwwrite(0x65FD00 + 9808 + 133 * 4, v.Boss_Hp[0] * 256);
                f_dwwrite(0x65FD00 + 9808 + 133 * 4, v.Boss_Hp[0] * 256)
                # (Line 103) CreateUnit(1, 133, "Line_Event", P6);
                # (Line 104) }
                DoActions(CreateUnit(1, 133, "Line_Event", P6))
                # (Line 106) break;
            EUDEndIf()
            EUDBreak()
            # (Line 107) }
        # (Line 108) }
        EUDEndSwitch()
        # (Line 109) }
    EUDEndIf()
    # (Line 111) function Start_Round_Text(cp)

# (Line 112) {
@EUDFunc
def Start_Round_Text(cp):
    # (Line 113) if(STSound[cp] != dwread_epd(213 * 12 + cp))
    if EUDIf()(STSound[cp] == f_dwread_epd(213 * 12 + cp), neg=True):
        # (Line 114) {
        # (Line 115) STSound[cp] = dwread_epd(213 * 12 + cp);
        _ARRW(STSound, cp) << (f_dwread_epd(213 * 12 + cp))
        # (Line 117) s.print("\n\n\n\x13\x19", dwread_epd(185 * 12 + 6), "주차 \x04스케줄 시작\n\n");
        s.print("\n\n\n\x13\x19", f_dwread_epd(185 * 12 + 6), "주차 \x04스케줄 시작\n\n")
        # (Line 118) s.print("\x13", ptr2s(t.Round_Unit_Name[STSound[cp]]), "\n\n\n");
        s.print("\x13", ptr2s(t.Round_Unit_Name[STSound[cp]]), "\n\n\n")
        # (Line 119) }
        # (Line 120) }
    EUDEndIf()
    # (Line 122) function End_Round_Text(cp)

# (Line 123) {
@EUDFunc
def End_Round_Text(cp):
    # (Line 124) if(EDSound[cp] != dwread_epd(212 * 12 + cp))
    if EUDIf()(EDSound[cp] == f_dwread_epd(212 * 12 + cp), neg=True):
        # (Line 125) {
        # (Line 126) EDSound[cp] = dwread_epd(212 * 12 + cp);
        _ARRW(EDSound, cp) << (f_dwread_epd(212 * 12 + cp))
        # (Line 128) s.print("\n\n\n\x13\x19", dwread_epd(185 * 12 + 6), "주차 \x04스케줄 완료\n\n");
        s.print("\n\n\n\x13\x19", f_dwread_epd(185 * 12 + 6), "주차 \x04스케줄 완료\n\n")
        # (Line 129) s.print("\x13", ptr2s(t.Round_Unit_Name[EDSound[cp]]));
        s.print("\x13", ptr2s(t.Round_Unit_Name[EDSound[cp]]))
        # (Line 130) s.print("\x13\x04", ptr2s(t.End_Sound_Text[EDSound[cp]]), "\n\n\n");
        s.print("\x13\x04", ptr2s(t.End_Sound_Text[EDSound[cp]]), "\n\n\n")
        # (Line 131) }
        # (Line 132) }
    EUDEndIf()
