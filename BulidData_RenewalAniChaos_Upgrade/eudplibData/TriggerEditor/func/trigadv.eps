import PluginVariables as msqcvar;
import variable as v;
import func.trig as trg;

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 점을 그릴때 사용합니다.
 * [baseunit]의 유닛을 기준으로 [pos_x], [pos_y] 만큼 로케이션을 이동한후 해당위치에 [unit]을 [count]만큼 생성합니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.pos_x.ko-KR
 * [pos_x] : 이동할 X좌표의 크기입니다.
 * @param.pos_y.ko-KR
 * [pos_y] : 이동할 Y좌표의 크기입니다.
***/
function Shape_DotAt(playerID : TrgPlayer, baseunit : TrgUnit, count, unit : TrgUnit, pos_x, pos_y)
{
	trg.MoveLoc(baseunit ,playerID, pos_x, pos_y);
	trg.SkillUnit(playerID, count, unit);
}

/***
 * @Type
 * 사용하지 마세요
***/
function Shape_DotAt2(playerID : TrgPlayer, count, unit : TrgUnit, pos_x, pos_y)
{
	trg.MoveLoc(v.P_UnitID[playerID] ,playerID, pos_x, pos_y);
	trg.SkillUnit(playerID, count, unit);
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 두점을 그릴때 사용합니다.
 * [baseunit]의 유닛을 기준으로 [pos_x], [pos_y] 만큼 로케이션을 이동한후 해당위치에 [unit]을 [count]만큼 생성합니다.
 * ex) pos_x = 5, pos_y = 3 일때, [5, 3], [-3, -5]가 그려집니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.pos_x.ko-KR
 * [pos_x] : 이동할 X좌표의 크기입니다.
 * @param.pos_y.ko-KR
 * [pos_y] : 이동할 Y좌표의 크기입니다.
***/
function Shape_DoubleAt(playerID : TrgPlayer, baseunit : TrgUnit, count, unit : TrgUnit, pos_x, pos_y)
{
	Shape_DotAt(playerID, baseunit, count, unit, pos_x, pos_y);
	Shape_DotAt(playerID, baseunit, count, unit, -pos_x, -pos_y);
}

/***
 * @Type
 * 사용하지 마세요
***/
function Shape_DoubleAt2(playerID : TrgPlayer, count, unit : TrgUnit, pos_x, pos_y)
{
	Shape_DotAt2(playerID, v.P_UnitID[playerID], count, unit, pos_x, pos_y);
	Shape_DotAt2(playerID, v.P_UnitID[playerID], count, unit, -pos_x, -pos_y);
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 사각형을 그릴때 사용합니다. 각 꼭지점에 유닛이 생성됩니다.
 * [baseunit]의 유닛을 기준으로 [pos_x], [pos_y] 만큼 로케이션을 이동한후 해당위치에 [unit]을 [count]만큼 생성합니다.
 * 사각형으로 출력됩니다. 
 * ex) pos_x = 5, pos_y = 3 일때, [5, 3], [-3, 5], [-5, -3], [3, -5]
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.pos_x.ko-KR
 * [pos_x] : 이동할 X좌표의 크기입니다.
 * @param.pos_y.ko-KR
 * [pos_y] : 이동할 Y좌표의 크기입니다.
***/
function Shape_SquareAt(playerID : TrgPlayer, baseunit : TrgUnit, count, unit : TrgUnit, pos_x, pos_y)
{
	trg.MoveLoc(baseunit, playerID, pos_x, pos_y);
	trg.SkillUnit(playerID, count, unit);
	trg.MoveLoc(baseunit, playerID, -pos_y, pos_x);
	trg.SkillUnit(playerID, count, unit);
	trg.MoveLoc(baseunit, playerID, -pos_x, -pos_y);
	trg.SkillUnit(playerID, count, unit);
	trg.MoveLoc(baseunit, playerID, pos_y, -pos_x);
	trg.SkillUnit(playerID, count, unit);
}


/***
 * @Type
 * 사용하지 마세요
***/
function Shape_SquareAt2(playerID : TrgPlayer, count, unit : TrgUnit, pos_x, pos_y)
{
	trg.MoveLoc(v.P_UnitID[playerID] ,playerID, pos_x, pos_y);
	trg.SkillUnit(playerID, count, unit);
	trg.MoveLoc(v.P_UnitID[playerID] ,playerID, -pos_y, pos_x);
	trg.SkillUnit(playerID, count, unit);
	trg.MoveLoc(v.P_UnitID[playerID] ,playerID, -pos_x, -pos_y);
	trg.SkillUnit(playerID, count, unit);
	trg.MoveLoc(v.P_UnitID[playerID] ,playerID, pos_y, -pos_x);
	trg.SkillUnit(playerID, count, unit);
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 정사각형을 그릴때 사용합니다. 꽉찬 사각형이 그려집니다.
 * [baseunit]의 유닛을 기준으로 [size]크기 만큼의 정사각형에 [unit]을 [interval]마다 [count]개 생성합니다.
 * ex) size = 3, count = 2 일때, 3 x 3 크기의 정사각형이 생성되며 총 (3 x 3) x 2 [(size x size) x count] 개의 유닛이 생성됩니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.size.ko-KR
 * [size] : 사각형의 크기입니다.
 * @param.interval.ko-KR
 * [interval] : 사각형안의 유닛마다의 거리입니다.
***/
function Shape_NxNSquareAt(playerID : TrgPlayer, baseunit : TrgUnit, count, unit : TrgUnit, size, interval)
{
	var loop = (size * size) / 4;
	var space = interval / 2;
	var dis_x, dis_y;
	
	if (size == 1)
	{ 
		Shape_DotAt(playerID, baseunit, count, unit, 0, 0);
	}
	else if (size > 1)
	{
		foreach(idx : EUDLoopRange(loop))
		{
			if (size % 2 == 0)
			{
				dis_x = idx % (size / 2) + 1;
				dis_y = idx / (size / 2) + 1;
				if (dis_x == 1)
				{ Shape_SquareAt(playerID, baseunit, count, unit, space, dis_y * interval - space); }
				else if (dis_y == 1)
				{ Shape_SquareAt(playerID, baseunit, count, unit, dis_x * interval - space, space); }
				else 
				{ Shape_SquareAt(playerID, baseunit, count, unit, dis_x * interval - space, dis_y * interval - space); }
			}
			else if (size % 2 == 1)
			{
				dis_x = idx % (size / 2);
				dis_y = idx / (size / 2);
				
				if (idx == 0)
				{ Shape_DotAt(playerID, baseunit, count, unit, 0, 0); }
				else if (dis_y == 0)
				{ Shape_SquareAt(playerID, baseunit, count, unit, dis_x * interval, 0); }
				else
				{ Shape_SquareAt(playerID, baseunit, count, unit, dis_x * interval + interval, dis_y * interval); }
				
				if (idx == loop - 1)
				{ Shape_SquareAt(playerID, baseunit, count, unit, (size / 2) * interval, 0); }
			}
		}
	}
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 정사각형을 그릴때 사용합니다. 꽉찬 사각형이 그려집니다.
 * [baseunit]의 유닛을 기준으로 [size]크기 만큼의 정사각형에 [unit]을 [interval]마다 [count]개 생성합니다.
 * ex) size = 3, count = 2 일때, 3 x 3 크기의 정사각형이 생성되며 총 (3 x 3) x 2 [(size x size) x count] 개의 유닛이 생성됩니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.size.ko-KR
 * [size] : 사각형의 크기입니다.
 * @param.interval.ko-KR
 * [interval] : 사각형안의 유닛마다의 거리입니다.
***/
function Shape_NxNSquareAt2(playerID : TrgPlayer, count, unit : TrgUnit, size, interval, x, y)
{
	var loop = (size * size) / 4;
	var space = interval / 2;
	var dis_x, dis_y;
	
	if (size == 1)
	{ 
		Shape_DotAt2(playerID, count, unit, x, y);
	}
	else if (size > 1)
	{
		foreach(idx : EUDLoopRange(loop))
		{
			if (size % 2 == 0)
			{
				dis_x = idx % (size / 2) + 1;
				dis_y = idx / (size / 2) + 1;
				if (dis_x == 1)
				{ Shape_SquareAt2(playerID, count, unit, x + space, y + dis_y * interval - space); }
				else if (dis_y == 1)
				{ Shape_SquareAt2(playerID, count, unit, x + dis_x * interval - space, y + space); }
				else 
				{ Shape_SquareAt2(playerID, count, unit, x + dis_x * interval - space, y + dis_y * interval - space); }
			}
			else if (size % 2 == 1)
			{
				dis_x = idx % (size / 2);
				dis_y = idx / (size / 2);
				
				if (idx == 0)
				{ Shape_DotAt2(playerID, count, unit, x, y); }
				else if (dis_y == 0)
				{ Shape_SquareAt2(playerID, count, unit, x + dis_x * interval, y); }
				else
				{ Shape_SquareAt2(playerID, count, unit, x + dis_x * interval + interval, y + dis_y * interval); }
				
				if (idx == loop - 1)
				{ Shape_SquareAt2(playerID, count, unit, x + (size / 2) * interval, y); }
			}
		}
	}
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 직선을 그릴때 사용합니다.
 * [baseunit]의 유닛을 기준으로 [size]크기 만큼의 직선을 [degree]만큼 기울이며 [unit]을 [interval]마다 [degree] x [distance]만큼 이동하여 [count]개 생성합니다.
 * ex) size = 3, count = 2 일때, 3 크기의 직선이 생성되며 총 3 x 2 [size x count] 개의 유닛이 생성됩니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.degree.ko-KR
 * [degree] : 직선의 기울기입니다.
 * @param.size.ko-KR
 * [size] : 직선의 크기입니다.
 * @param.interval.ko-KR
 * [interval] : 직선의 유닛마다의 거리입니다.
 * @param.distance.ko-KR
 * [distance] : 기울기 만큼 떨어진 위치를 정합니다. 캐릭터 위에 직선을 그릴 시 0 입니다.
***/
function Shape_LineAt(playerID : TrgPlayer, count, baseunit : TrgUnit, unit : TrgUnit, degree, size, interval, distance)
{
	trg.Table_Sin(playerID, degree + 90, distance);
	trg.Table_Cos(playerID, degree + 90, distance);
	
	var initial_x = v.P_AngleCos[playerID];
	var initial_y = v.P_AngleSin[playerID];
	
	if (size % 2 == 0)
	{ trg.Table_Sin(playerID, degree, interval * (size / 2) - interval / 2); trg.Table_Cos(playerID, degree, interval * (size / 2) - interval / 2); }
	else
	{ trg.Table_Sin(playerID, degree, interval * (size / 2)); trg.Table_Cos(playerID, degree, interval * (size / 2)); }
	
	initial_x = initial_x + v.P_AngleCos[playerID];
	initial_y = initial_y + v.P_AngleSin[playerID];
	
	trg.Table_Sin(playerID, degree, interval);
	trg.Table_Cos(playerID, degree, interval);
	
	if (size == 1)
	{ Shape_DotAt(playerID, baseunit, count, unit, 0, 0); }
	else if (size > 1)
	{ foreach(idx : EUDLoopRange(size)) { Shape_DotAt(playerID, baseunit, count, unit, initial_x - idx * v.P_AngleCos[playerID], initial_y - idx * v.P_AngleSin[playerID]); } }
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 십자를 그릴때 사용합니다.
 * [baseunit]의 유닛을 기준으로 [size]크기 만큼의 십자를 [degree]만큼 기울이며 [unit]을 [interval]마다 [degree] x [distance]만큼 이동하여 [count]개 생성합니다.
 * ex) size = 3, count = 2 일때, 3 크기의 십자가 생성되며 총 3 x 2 x 2 [size x 2 x count] 개의 유닛이 생성됩니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.degree.ko-KR
 * [degree] : 십자의 기울기입니다.
 * @param.size.ko-KR
 * [size] : 십자의 크기입니다.
 * @param.interval.ko-KR
 * [interval] : 십자의 유닛마다의 거리입니다.
***/
function Shape_CrossAt(playerID : TrgPlayer, count, baseunit : TrgUnit, unit : TrgUnit, degree, size, interval)
{
	var distance = interval / 2;

	trg.Table_Sin(playerID, degree, distance);
	trg.Table_Cos(playerID, degree, distance);
	
	var gradient_x = v.P_AngleCos[playerID] / 2;
	var gradient_y = v.P_AngleSin[playerID] / 2;
	
	var angle_x, angle_y;
	
	trg.Table_Sin(playerID, degree, interval);
	trg.Table_Cos(playerID, degree, interval);
	
	if (size == 1)
	{
		Shape_DotAt(playerID, baseunit, count, unit, 0, 0);
	}
	else if (size > 1)
	{
		foreach(idx : EUDLoopRange(size))
		{
			angle_x = v.P_AngleCos[playerID] * idx;
			angle_y = v.P_AngleSin[playerID] * idx;
			
			if (size % 2 == 0 && idx != size / 2)
			{ Shape_SquareAt(playerID, baseunit, count, unit, angle_x + gradient_x, angle_y + gradient_y); }
			else if (size % 2 == 1)
			{
				if (idx == 0)
				{ Shape_DotAt(playerID, baseunit, count, unit, 0, 0); }
				else
				{ Shape_SquareAt(playerID, baseunit, count, unit, angle_x, angle_y); }
			}
		}
	}
}

/***
 * @Type
 * F
 * @Summary.ko-KR
 * 외곽선만 가진 정사각형을 그릴떄 사용합니다. *기본 45도 마름모꼴
 * [baseunit]의 유닛을 기준으로 [size]크기 만큼의 정사각형을 [degree]만큼 기울이며 [unit]을 [interval]마다 [degree] x [distance]만큼 이동하여 [count]개 생성합니다.
 * ex) size = 3, count = 2 일때, 3 크기의 정사각형이 생성되며 총 3 x 4 x 2 - 4 [size x 4 x count - 4] 개의 유닛이 생성됩니다.
 * @param.playerID.ko-KR
 * [playerID] : 유닛의 소유자를 정합니다.
 * @param.count.ko-KR
 * [count] : 생성될 유닛의 갯수를 정합니다.
 * @param.baseunit.ko-KR
 * [baseunit] : 로케이션 기준이될 유닛을 정합니다.
 * @param.unit.ko-KR
 * [unit] : 생성될 유닛을 정합니다.
 * @param.degree.ko-KR
 * [degree] : 정사각형의 기울기입니다.
 * @param.size.ko-KR
 * [size] : 한변당 유닛의 갯수입니다.
 * @param.interval.ko-KR
 * [interval] : 정사각형의 크기입니다.
***/
function Shape_EdgeAt(playerID : TrgPlayer, count, unit : TrgUnit, degree, size, interval, x, y)
{
	trg.Table_Sin(playerID, degree, interval * 14 / 10);
	trg.Table_Cos(playerID, degree, interval * 14 / 10);
	
	var x_o = v.P_AngleCos[playerID];
	var y_o = v.P_AngleSin[playerID];

	var distance = (interval * 2) / (size - 1);

	trg.Table_Sin(playerID, degree + 45, distance);
	trg.Table_Cos(playerID, degree + 45, distance);

	var distance_x = v.P_AngleCos[playerID];
	var distance_y = v.P_AngleSin[playerID];
   
	if (size == 1)
	{ Shape_DotAt(playerID, v.P_UnitID[playerID], 1, unit, x, y); }
	else if (size > 1)
	{ foreach(idx : EUDLoopRange(size - 1)) { Shape_SquareAt(playerID, v.P_UnitID[playerID], 1, unit, x + x_o - (distance_x * idx), y + y_o - (distance_y * idx)); } }
}